This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: src/**/*.mdx, **/*.stories
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)


================================================================
Directory Structure
================================================================
src/
  pages/
    blocks/
      administration/
        billing.mdx
        pricing.mdx
        profile.mdx
        team.mdx
      authentication/
        forgot-password.mdx
        login.mdx
        mfa.mdx
        register.mdx
      foundation/
        contact.mdx
        empty-state.mdx
        not-found.mdx
        timeline.mdx
      index.mdx
    docs/
      advanced/
        best-practices.mdx
        tools.mdx
      components/
        data/
          data-size.mdx
          date-format.mdx
          duration.mdx
          ellipsis.mdx
          infinity-list.mdx
          pager.mdx
          pluralize.mdx
          redact.mdx
          sort.mdx
        elements/
          avatar-group.mdx
          avatar.mdx
          badge.mdx
          button.mdx
          chip.mdx
          command-palette.mdx
          icon-button.mdx
          kbd.mdx
          loader.mdx
        form/
          calendar.mdx
          checkbox.mdx
          date-input.mdx
          debounced-input.mdx
          inline-input.mdx
          input.mdx
          radio.mdx
          range.mdx
          select.mdx
          textarea.mdx
          toggle.mdx
        layers/
          backdrop.mdx
          confirm-dialog.mdx
          context-menu.mdx
          dialog.mdx
          drawer.mdx
          menu.mdx
          notification.mdx
          popover.mdx
          tooltip.mdx
        layout/
          block.mdx
          breadcrumbs.mdx
          callout.mdx
          card.mdx
          collapse.mdx
          divider.mdx
          json-tree.mdx
          list.mdx
          motion.mdx
          stack.mdx
          stepper.mdx
          tabs.mdx
          tree.mdx
          vertical-spacer.mdx
        typography/
          typography.mdx
      getting-started/
        migration.mdx
        philosophy.mdx
        setup.mdx
        storybook.mdx
      recipes/
        animations.mdx
        forms.mdx
        table.mdx
        uploads.mdx
      theme/
        getting-started.mdx
        theme-api.mdx
        theme-block.mdx
        theme-example.mdx
        theme-icons.mdx
      utils/
        component-theme.mdx
        cursor.mdx
        exit-listener.mdx
        id.mdx
        overlay.mdx
        portal.mdx
        position.mdx
        theme.mdx
        user-select.mdx
      changelog.mdx
      index.mdx
    support.mdx

================================================================
Files
================================================================

================
File: src/pages/blocks/administration/billing.mdx
================
import { Canvas, Meta } from '@storybook/blocks';
import * as BillingStories from '../../../stories/blocks/Billing.story';
import { ToggleCanvas } from '@/components/ui/toggle-canvas';

<Meta of={BillingStories} />

# Billing

The Billing block enables users to manage and view subscriptions, plans, usage, payment information, and other billing related information within your product.

## Billing Full
<ToggleCanvas of={BillingStories.BillingFull} />

## Pay And Billing
<ToggleCanvas of={BillingStories.PayAndBilling} />

## Billing Subscription
<ToggleCanvas of={BillingStories.BillingSubscription} />

## Billing Information
<ToggleCanvas of={BillingStories.BillingInformation} />

================
File: src/pages/blocks/administration/pricing.mdx
================
import { Canvas, Meta } from '@storybook/blocks';
import * as PricingStories from '../../../stories/blocks/Pricing.story';
import { ToggleCanvas } from '@/components/ui/toggle-canvas';

<Meta of={PricingStories} />

# Pricing

The Pricing block is for displaying pricing tables and managing active plans

<ToggleCanvas of={PricingStories.Pricing} />

## Pricing Full
<ToggleCanvas of={PricingStories.PricingFull} />

## Pricing Minimal
<ToggleCanvas of={PricingStories.PricingMinimal} />

================
File: src/pages/blocks/administration/profile.mdx
================
import { Canvas, Meta } from '@storybook/blocks';
import * as ProfileStories from '../../../stories/blocks/Profile.story';
import { ToggleCanvas } from '@/components/ui/toggle-canvas';

<Meta of={ProfileStories} />

# Profile

The profile blocks serve a crucial function in applications, providing interfaces for displaying and editing user information. These blocks can enhance user engagement by allowing users to personalize their interaction with the application.

## Profile
<ToggleCanvas of={ProfileStories.Profile} />

## Account
<ToggleCanvas of={ProfileStories.Account} />

## Overview
<ToggleCanvas of={ProfileStories.Overview} />

## Settings
<ToggleCanvas of={ProfileStories.Settings} />

================
File: src/pages/blocks/administration/team.mdx
================
import { Canvas, Meta } from '@storybook/blocks';
import * as TeamStories from '../../../stories/blocks/Team.story';
import { ToggleCanvas } from '@/components/ui/toggle-canvas';

<Meta of={TeamStories} />

# Team

The Team blocks provide a comprehensive view of team members and their roles within the organization. This block can be used manage team and assign roles and permissions.

## Team General
<ToggleCanvas of={TeamStories.TeamGeneral} />

## Team Minimal
<ToggleCanvas of={TeamStories.TeamMinimal} />

## Team Roles
<ToggleCanvas of={TeamStories.TeamRoles} />

================
File: src/pages/blocks/authentication/forgot-password.mdx
================
import { Canvas, Meta } from '@storybook/blocks';
import * as ForgotPasswordStories from '../../../stories/blocks/ForgotPassword.story';
import { ToggleCanvas } from '@/components/ui/toggle-canvas';

<Meta of={ForgotPasswordStories} />

# Forgot Password

The Forgot Password block allows users to reset their passwords, ensuring they can regain access to their accounts even if they forget their passwords.

<ToggleCanvas of={ForgotPasswordStories.ForgotPassword} />

## Forgot Password Full
<ToggleCanvas of={ForgotPasswordStories.ForgotPasswordFull} />

## Forgot Password Minimal
<ToggleCanvas of={ForgotPasswordStories.ForgotPasswordMinimal} />

## Reset Password
<ToggleCanvas of={ForgotPasswordStories.ResetPassword} />

## Reset Password Minimal
<ToggleCanvas of={ForgotPasswordStories.ResetPasswordMinimal} />

================
File: src/pages/blocks/authentication/login.mdx
================
import { Canvas, Meta } from '@storybook/blocks';
import * as LoginStories from '../../../stories/blocks/Login.story';
import { ToggleCanvas } from '@/components/ui/toggle-canvas';

<Meta of={LoginStories} />

# Login

The Login block is the gateway for users to access their accounts, providing a simple yet secure login form.

<ToggleCanvas of={LoginStories.Login} />

## Login Basic
<ToggleCanvas of={LoginStories.LoginBasic} />

## Login Full
<ToggleCanvas of={LoginStories.LoginFull} />

## Login Password
<ToggleCanvas of={LoginStories.LoginPassword} />

## Login Social
<ToggleCanvas of={LoginStories.LoginSocial} />

================
File: src/pages/blocks/authentication/mfa.mdx
================
import { Canvas, Meta } from '@storybook/blocks';
import * as MfaStories from '../../../stories/blocks/Mfa.story';
import { ToggleCanvas } from '@/components/ui/toggle-canvas';

<Meta of={MfaStories} />

# MFA

The MFA block facilitates capturing a user's MFA code and verifying it.

<ToggleCanvas of={MfaStories.Mfa} />

## MFA Login
<ToggleCanvas of={MfaStories.MfaLogin} />

## MFA Authenticator
<ToggleCanvas of={MfaStories.MfaAuthenticator} />

================
File: src/pages/blocks/authentication/register.mdx
================
import { Canvas, Meta } from '@storybook/blocks';
import * as RegisterStories from '../../../stories/blocks/Register.story';
import { ToggleCanvas } from '@/components/ui/toggle-canvas';

<Meta of={RegisterStories} />

# Register

The Register block facilitates new user registrations, capturing essential information to create user accounts.

<ToggleCanvas of={RegisterStories.Register} />

## RegisterFull
<ToggleCanvas of={RegisterStories.RegisterFull} />

## RegisterV2
<ToggleCanvas of={RegisterStories.RegisterV2} />

## RegisterWithSocial
<ToggleCanvas of={RegisterStories.RegisterWithSocial} />

================
File: src/pages/blocks/foundation/contact.mdx
================
import { Canvas, Meta } from '@storybook/blocks';
import * as SupportStories from '../../../stories/blocks/Support.story';
import { ToggleCanvas } from '@/components/ui/toggle-canvas';

<Meta of={SupportStories} />

# Chat

The chat block provides a way to provide the user the ability to send messages.

## Report an Issue

<ToggleCanvas of={SupportStories.Support} />

================
File: src/pages/blocks/foundation/empty-state.mdx
================
import { Canvas, Meta } from '@storybook/blocks';
import * as EmptyStateStories from '../../../stories/blocks/EmptyState.story';
import { ToggleCanvas } from '@/components/ui/toggle-canvas';

<Meta of={EmptyStateStories} />

# Empty State

The Empty State blocks are useful when a component has no data to display. This is a common scenario when a user has just signed up or has not yet created any content.

## No Results
<ToggleCanvas of={EmptyStateStories.NoResults} />

## Missing Info
<ToggleCanvas of={EmptyStateStories.MissingInfo} />

## Nothing to Display
<ToggleCanvas of={EmptyStateStories.NothingToDisplay} />

================
File: src/pages/blocks/foundation/not-found.mdx
================
import { Canvas, Meta } from '@storybook/blocks';
import * as NotFoundStories from '../../../stories/blocks/NotFound.story';
import { ToggleCanvas } from '@/components/ui/toggle-canvas';

<Meta of={NotFoundStories} />

# Not Found

The Not Found block provides a way to provide the user with feedback that something is wrong
or when a user tries to access a page they do not have access to.

## We Lost This Page
<ToggleCanvas of={NotFoundStories.NotFound} />

## Does Not Exist
<ToggleCanvas of={NotFoundStories.DoesNotExist} />

## Lost Page
<ToggleCanvas of={NotFoundStories.LostPage} />

================
File: src/pages/blocks/foundation/timeline.mdx
================
import { Canvas, Meta } from '@storybook/blocks';
import * as TimelineStories from '../../../stories/blocks/Timeline.story';
import { ToggleCanvas } from '@/components/ui/toggle-canvas';

<Meta of={TimelineStories} />

# Timeline

## Activity Timeline
<ToggleCanvas of={TimelineStories.ActivityTimeline} />

## Version History
<ToggleCanvas of={TimelineStories.VersionHistory} />

## Workspace History
<ToggleCanvas of={TimelineStories.WorkspaceHistory} />

================
File: src/pages/blocks/index.mdx
================
import { Cards } from 'nextra/components'

import img from '../../icons/preview2.png';

<div className="my-0 mx-auto text-white text-center flex flex-col">
  <img
    className="mx-auto mb-8 mt-8"
    src={img.src}
  />
  ---
</div>

Blocks are sets of pre-built components that create a feature. For example, a login
block might have a variety of styling and form layouts for it. Reablocks comes with
a variety of these blocks to help you stich together your application faster.
We offer the following blocks out of the box:

### Foundation
<Cards>
  <Cards.Card title="😱 Not Found" href="/blocks/foundation/not-found" />
  <Cards.Card title="❌ Empty State" href="/blocks/foundation/empty-state" />
  <Cards.Card title="🗣️ Contact" href="/blocks/foundation/contact" />
  <Cards.Card title="⏳ Timeline" href="/blocks/foundation/timeline" />
</Cards>

### Authentication
<Cards>
  <Cards.Card title="🔐 Login" href="/blocks/authentication/login" />
  <Cards.Card title="🤷‍♂️ Forgot Password" href="/blocks/authentication/forgot-password" />
  <Cards.Card title="📝 Register" href="/blocks/authentication/register" />
  <Cards.Card title="☎️ MFA" href="/blocks/authentication/mfa" />
</Cards>

### Administration
<Cards>
  <Cards.Card title="👦 Profile" href="/blocks/administration/profile" />
  <Cards.Card title="💰 Pricing" href="/blocks/administration/pricing" />
  <Cards.Card title="💸 Billing" href="/blocks/administration/billing" />
  <Cards.Card title="👬 Team" href="/blocks/administration/team" />
</Cards>

================
File: src/pages/docs/advanced/best-practices.mdx
================
# Best Practices

## Palettes over Colors
When using Tailwind CSS, it's best to use palettes over colors when styling components.
This is because palettes are more flexible and can be used in multiple places,
while colors are more specific and can only be used in one place.

For example, instead of using `bg-blue-500` like:

```tsx
const Button = () => (
  <button className="bg-blue-500 text-white">Click me</button>
);
```

You should use `bg-primary` like:

```tsx
const Button = () => (
  <button className="bg-primary text-white">Click me</button>
);
```

================
File: src/pages/docs/advanced/tools.mdx
================
# Tools

### IntelliSense
Tailwind has a number of tools that can help you build your Tailwind projects more effectively.
One tool that is particularly useful is the Tailwind CSS IntelliSense extension for [Visual Studio Code](https://marketplace.visualstudio.com/items?itemName=bradlc.vscode-tailwindcss).

### Code Folding
Another useful tool is the Tailwind CSS code folding extension for
 [Visual Studio Code](https://marketplace.visualstudio.com/items?itemName=stivo.tailwind-fold). This
 makes it easier to navigate your Tailwind CSS classes by folding them into a single line.

================
File: src/pages/docs/components/data/data-size.mdx
================
import { Canvas, Meta, ArgTypes } from '@storybook/blocks';
import * as DateSizeStories from '../../../../stories/components/DataSize.story.tsx';
import { PropsTable } from '@/components/ui/props-table';
import { ToggleCanvas } from '@/components/ui/toggle-canvas';
import { Runner } from '@/components/ui/runner';

# Data Size
The Data Size component is designed to display data sizes in a human-readable format.
Leveraging the [human-format](https://www.npmjs.com/package/human-format) library, it simplifies the representation of byte values into more understandable formats such as bytes (B), kilobytes (KiB), megabytes (MiB), and so forth, up to yottabytes (YiB).

<Meta of={DateSizeStories} />

## Quick Start
To start using the `DataSize` component, import it from the `reablocks` library and enter the desired byte value as the `value` prop

<Runner code={`import { DataSize } from 'reablocks';

export default function App() {
  return (
    <DataSize value={324344535345232482} />
  );
}`}
/>

## Examples

### Basic Usage
You can directly use the `DataSize` component to render data sizes.
Here's a basic example demonstrating how various byte values are converted into human-readable formats:

<ToggleCanvas of={DateSizeStories.Simple} storybook="components-data-data-size--simple" />

### Handling Null/Undefined Values
The component allows for a customizable placeholder string to be displayed when the input value is `null` or `undefined`,
enhancing the flexibility in various use cases:

<ToggleCanvas of={DateSizeStories.Empty} storybook="components-data-data-size--empty" />

## API
The `DataSize` component and the `formatSize` function come with several configurable options:

### Component API
<PropsTable name="DateFormat" />

### Function API
For more advanced scenarios or when you need to programmatically format data sizes within your application logic,
you can use the `formatSize` function provided by the API:

```ts
import { formatSize, FormatSizeTypes } from 'reablocks';

function yourFunction(size: FormatSizeTypes) {
  // size = number | string | null | undefined;
  return formatSize(size);
}
```

## Design and Usability Tips

- **Intuitive Units:** Automatically adjust units for data size to the most intuitive option (e.g., automatically displaying in MB instead of KB for large files), enhancing readability.

================
File: src/pages/docs/components/data/date-format.mdx
================
import { Canvas, Meta } from '@storybook/blocks';
import * as DateFormatStories from '../../../../stories/components/DateFormat.story.tsx';
import { PropsTable } from '@/components/ui/props-table';
import { ToggleCanvas } from '@/components/ui/toggle-canvas';
import { Runner } from '@/components/ui/runner';

<Meta of={DateFormatStories} />

# Date Format
The Date Format component simplifies the process of converting standard date formats into more readable forms or formats tailored to the user's locale preferences.
Leveraging the capabilities of [date-fns](https://www.npmjs.com/package/date-fns) flexibility in displaying dates in both absolute and relative terms.

## Quick Start
To start using the `DateFormat` component, import it from the `reablocks` library and provide the `date` and `format` props.

<Runner code={`import { DateFormat } from 'reablocks';

export default function App() {
  return (
    <DateFormat
      date="2022-05-25T16:03:12.2085"
      format="MM/dd/yyyy hh:mm"
    />
  );
}`}
/>

## Examples
### Basic Usage
For straightforward applications, the component can directly format the current date and time into a default format.
<ToggleCanvas of={DateFormatStories.Simple} storybook="components-data-dateformat--simple" />

### Relative Time
The component also supports displaying dates in relative terms, such as "3 months ago", which can be particularly useful for content timestamps.
<ToggleCanvas of={DateFormatStories.Relative} storybook="components-data-dateformat--relative" />

## API
The `Date Format` component is highly configurable with several properties to adjust its behavior and output format:
<PropsTable name="DateFormat" />

## Design and Usability Tips

- **User Preference:** Allow users to select their preferred date format settings if possible, catering to global audiences and personal preferences.

================
File: src/pages/docs/components/data/duration.mdx
================
import { Canvas, Meta } from '@storybook/blocks';
import * as DurationStories from '../../../../stories/components/Duration.story.tsx';
import { PropsTable } from '@/components/ui/props-table';
import { ToggleCanvas } from '@/components/ui/toggle-canvas';
import { Runner } from '@/components/ui/runner';

<Meta of={DurationStories} />

# Duration
The Duration component is designed to represent time durations derived from epoch time values in an easily interpretable format.
It's suitable for displaying durations like processing times, event lengths, or intervals in a [human-format](https://www.npmjs.com/package/human-format).

## Quick Start
To start using the `Duration` component, import it from the `reablocks` library and provide the `value` props in miliseconds.

<Runner code={`import { Duration } from 'reablocks';

export default function App() {
  return (
    <Duration value="123459101" />
  );
}`}
/>

## Examples
<ToggleCanvas of={DurationStories.Simple} storybook="components-data-duration--simple" />

## API
### Component
<PropsTable name="Duration" />

### Function
For more advanced scenarios or when you need to programmatically format data sizes within your application logic,
you can use the `formatDuration` function provided by the API:

```ts
import { formatDuration, DurationFormatTypes } from 'reablocks';

function yourFunction(size: DurationFormatTypes) {
  // size = number | string | null | undefined;
  return formatDuration(size);
}
```

================
File: src/pages/docs/components/data/ellipsis.mdx
================
import { Canvas, Meta } from '@storybook/blocks';
import * as EllipsisStories from '../../../../stories/components/Ellipsis.story.tsx';
import { PropsTable } from '@/components/ui/props-table';
import { ToggleCanvas } from '@/components/ui/toggle-canvas';
import { Runner } from '@/components/ui/runner';

<Meta of={EllipsisStories} />

# Ellipsis
The Ellipsis component is designed to manage long strings of text by truncating them and optionally allowing users to expand the text to view in full.
This component is particularly useful for maintaining a clean UI when dealing with potentially lengthy content such as descriptions, comments, or articles.

This ellipsis component supports 2 different modes of operation:

- Limit based on the number of characters
- Limit based on the number of lines

It also supports a tooltip mode where the full text is visible on hover and the ability to expand/collapse the text.

## Quick Start
To start using the `Ellipsis` component, import it from the `reablocks` library and provide the `value` and `limit` props.

<Runner code={`import { Ellipsis } from 'reablocks';

export default function App() {
  const longString = "Integer a aliquet ligula. Fusce vel eros libero. Sed dictum tincidunt hendrerit. Integer id neque faucibus, imperdiet purus dapibus, rutrum tellus. Nullam facilisis odio sit amet metus efficitur.";

  return (
    <Ellipsis
      value={longString}
      limit={100}
    />
  );
}`}
/>

## Examples

### Basic Usage
#### Expandable Text Section
In this example, the text is truncated with an ellipsis,
and users can click on the ellipsis to reveal the hidden text:
<ToggleCanvas of={EllipsisStories.Simple} storybook="components-data-ellipsis--simple" />

#### Unexpandable Text Section
For cases where the full text should not be expanded within the component
but is visible via a tooltip on hover:
<ToggleCanvas of={EllipsisStories.Unexpandable} storybook="components-data-ellipsis--unexpandable" />

#### Line Clamping
<ToggleCanvas of={EllipsisStories.Lines} storybook="components-data-ellipsis--lines" />

## API
The `Ellipsis` component offers flexibility through several properties that adjust its behavior and presentation:
<PropsTable name="Ellipsis" />

## Design and Usability Tips

- **Content Access:** Ensure the full content is accessible through interaction (click to expand) or tooltips, preventing loss of critical information.
- **Adaptive Text:** Adjust the amount of truncated text based on the context and importance, ensuring key information is always visible to the user.

================
File: src/pages/docs/components/data/infinity-list.mdx
================
import { Canvas, Meta } from '@storybook/blocks';
import * as InfinityListStories from '../../../../stories/components/InfinityList.story.tsx';
import { PropsTable } from '@/components/ui/props-table';
import { ToggleCanvas } from '@/components/ui/toggle-canvas';
import { Runner } from '@/components/ui/runner';

<Meta of={InfinityListStories} />

# Infinity List
The Infinity List component is designed to manage large datasets by progressively
displaying a subset of items, enhancing performance and user experience.

This component is especially useful in scenarios where loading the entire dataset at
once is feasible, but displaying it all at once may overwhelm the user or the UI.

## Quick Start
To start using the `InfinityList` component, import `useInfinityList` from the `reablocks` library and provide the `items` prop to the hook.

<Runner code={`import { useMemo } from 'react';
import { useInfinityList } from 'reablocks';

export default function App() {
  const items = useMemo(() => [...Array(30).keys()], []);
  const { data, hasMore, showNext } = useInfinityList({ items });

  return (
    <div>
      {data.map(i => (
        <div key={i}>Item {i}</div>
      ))}
      {hasMore && <button onClick={() => showNext()}>Show More</button>}
    </div>
  );
}`}
/>

## Examples
The basic implementation uses the `InfinityList` component directly.
This approach is straightforward, allowing you to map over your dataset and render each item within the `InfinityList` component:

### Component
<ToggleCanvas of={InfinityListStories.Simple} storybook="components-data-infinitylist--simple" />

### Hook
<ToggleCanvas of={InfinityListStories.Hook} storybook="components-data-infinitylist--hook" />

## API
<PropsTable name="InfinityList" />

================
File: src/pages/docs/components/data/pager.mdx
================
import { Canvas, Meta } from '@storybook/blocks';
import * as PagerStories from '../../../../stories/components/Pager.story.tsx';
import { PropsTable } from '@/components/ui/props-table';
import { ToggleCanvas } from '@/components/ui/toggle-canvas';
import { Runner } from '@/components/ui/runner';

<Meta of={PagerStories} />

# Pager
The Pager component facilitates navigation through pages of data,
allowing users to easily switch between different subsets of data.
It supports customization of navigation indicators (arrows) and provides various display modes to tailor how pagination information is presented.

## Quick Start
To start using the `Pager` component, import it from the `reablocks` library and provide the `page`, `size`, `total` props. Anso set the `onPageChange` prop to handle page changes.

<Runner code={`import { useState } from 'react';
import { Pager } from 'reablocks';

export default function App() {
  const [page, setPage] = useState<number>(0);

  return (
    <Pager
      page={page}
      size={10}
      total={100}
      onPageChange={setPage}
      displayMode="pages"
    />
  );
}`}
/>

## Examples
### Basic Usage
#### Simple Pager with Page Numbers
In this example, the pager displays page numbers,
allowing users to navigate through pages based on a specific range of items:
<ToggleCanvas of={PagerStories.ShowPages} storybook="components-data-pager--show-pages" />

#### Displaying Range of Items
To show the current range of items (e.g., "1-10 of 100 items"),
you can set the displayMode to "items":
<ToggleCanvas of={PagerStories.ShowItems} storybook="components-data-pager--show-items" />

#### Comprehensive Pagination Information
For a more detailed view, including both page numbers and the items range, set `displayMode` to "all":
<ToggleCanvas of={PagerStories.ShowAll} storybook="components-data-pager--show-all" />

## API
The Pager component offers a range of properties for customization and flexibility:
<PropsTable name="Pager" />

## Design and Usability Tips

- **Predictable Navigation:** Design pager controls to be predictable and consistent, with clear indications of current page and total number of pages, aiding in orientation within the dataset.
- **Responsive Adaptation:** Ensure pager controls adapt responsively to different screen sizes, maintaining usability and accessibility on mobile devices.

================
File: src/pages/docs/components/data/pluralize.mdx
================
import { Canvas, Meta } from '@storybook/blocks';
import * as PluralizeStories from '../../../../stories/components/Pluralize.story.tsx';
import { PropsTable } from '@/components/ui/props-table';
import { ToggleCanvas } from '@/components/ui/toggle-canvas';
import { Runner } from '@/components/ui/runner';

<Meta of={PluralizeStories} />

# Pluralize
The Pluralize component dynamically renders words in their singular or plural form depending on the provided item count.
It supports customization for singular, plural, and zero-item states, making it ideal for UIs that need to display varying amounts of items or data points.

## Quick Start
To start using the `Pluralize` component, import it from the `reablocks` library and provide the `count` and `singular` props.

<Runner code={`import { Pluralize } from 'reablocks';

export default function App() {
  return <Pluralize count={20} singular="Apple" />
}`}
/>

## Examples
### Basic Usage
#### Singular and Plural Forms
In this basic example, we show how to render a word in both its singular and plural forms based on the count.
The component automatically appends an "s" to the singular form for the plural representation if the plural form is not explicitly provided:
<ToggleCanvas of={PluralizeStories.Simple} storybook="components-data-pluralize--simple" />

#### Custom Text for Zero Values
You can specify custom text to display when the count is zero, providing a more descriptive or friendly message.
<ToggleCanvas of={PluralizeStories.ZeroCount} storybook="components-data-pluralize--zero-count" />

## API
The Pluralize component's functionality is controlled through several properties:
<PropsTable name="Pluralize" />

## Design and Usability Tips

- **Contextual Awareness:** Ensure pluralized text dynamically adjusts to reflect the current state or count accurately, avoiding confusion or misinterpretation.

================
File: src/pages/docs/components/data/redact.mdx
================
import { Canvas, Meta } from '@storybook/blocks';
import * as RedactStories from '../../../../stories/components/Redact.story.tsx';
import { PropsTable } from '@/components/ui/props-table';
import { ToggleCanvas } from '@/components/ui/toggle-canvas';
import { Runner } from '@/components/ui/runner';

<Meta of={RedactStories} />

# Redact
The "Redact" component is a simple and intuitive way to redact info in scenarios where you need to hide confidential information, such as passwords, personal details, or any other sensitive text.
It uses [coverup](https://www.npmjs.com/package/coverup).

## Quick Start
To start using the `Redact` component, import it from the `reablocks` library and provide the `value` prop.

<Runner code={`import { Redact } from 'reablocks';

export default function App() {
  return <Redact value="Don't tell!" />
}`}
/>

## Examples
### Basic Usage
To redact text, simply pass the sensitive string you wish to hide to the value prop of the Redact component.
The component obscures the text, showing only a predefined number of characters as a placeholder:
<ToggleCanvas of={RedactStories.Basic} storybook="components-data-redact--basic" />

## API
The Redact component is highly customizable through the following properties:
<PropsTable name="Redact" />

## Design and Usability Tips

- **Toggle Simplicity:** Make toggling the visibility of redacted information simple and intuitive, using icons or textual cues that clearly indicate the action.
- **Sensitive Information Awareness:** Educate users about the sensitivity of the information being redacted, potentially through tooltips or help icons, to foster understanding and cautious interaction.

================
File: src/pages/docs/components/data/sort.mdx
================
import { Canvas, Meta } from "@storybook/blocks";
import * as SortStories from "../../../../stories/components/Sort.story.tsx";
import { PropsTable } from "@/components/ui/props-table";
import { ToggleCanvas } from "@/components/ui/toggle-canvas";
import { Runner } from "@/components/ui/runner";

<Meta of={SortStories} />

# Sort

The "Sort" component is a straightforward, user-friendly tool designed for toggling the sort direction of data within your application.
Ideal for data tables or lists that require sorting capabilities, it provides visual indicators for the current sort direction and allows users to change the sort order with a simple click.

## Quick Start

To start using the `Sort` component, import it from the `reablocks` library and provide the `direction` and `onSort` props.

<Runner code={`import { useState } from 'react';
import { Sort } from 'reablocks';

export default function App() {
  const [dir, setDir] = useState<SortDirection>('asc');
  return <Sort direction={dir} onSort={setDir}>
    Age
  </Sort>;
}`}
/>

## Examples

### Basic Usage

To use the Sort component, manage the sort direction state in your component or page and pass it along with a callback function to handle changes in sort direction.
This example demonstrates how to integrate the Sort component with ascending ('asc') and descending ('desc') sort directions:

<ToggleCanvas
  of={SortStories.Simple}
  storybook="components-data-sort--simple"
/>

## API

Customize the Sort component using the following properties:

<PropsTable name="Sort" />

## Design and Usability Tips

- **Sort Confirmation:** Provide immediate visual feedback when a sort order is applied, such as highlighting the active sort column or displaying a sorted icon, reinforcing the user's action.

================
File: src/pages/docs/components/elements/avatar-group.mdx
================
import { Canvas, Meta } from '@storybook/blocks';
import * as AvatarGroupStories from '../../../../stories/components/AvatarGroup.story.tsx';
import { avatarGroupTheme } from 'reablocks';
import { PropsTable } from '@/components/ui/props-table';
import { ToggleCanvas } from '@/components/ui/toggle-canvas';
import ThemeRender from '@/components/ui/theme-render';
import { Runner } from '@/components/ui/runner';

<Meta of={AvatarGroupStories} />

# AvatarGroup
The `AvatarGroup` component is designed to efficiently display a collection of user avatars,
making it ideal for showcasing team members, participant lists, or any group of users.
It smartly handles large numbers of avatars by showing a set maximum number on the screen,
with an additional indicator for the number of hidden avatars.

## Quick Start
To start using the `AvatarGroup` component, import it and the `Avatar` component from the `reablocks` library and provide the appropriate `name` props.

<Runner code={`import { AvatarGroup, Avatar } from 'reablocks';

export default function App() {
  return (
    <AvatarGroup>
      <Avatar name="Ben Franklin" />
      <Avatar name="Teddy Roosevelt" />
      <Avatar name="Bugs Bunny" />
    </AvatarGroup>
  )
}`}
/>

## Examples
### Basic Usage
The AvatarGroup component arranges multiple Avatar components together, indicating excess
 avatars when surpassing the specified maximum size:

<ToggleCanvas of={AvatarGroupStories.Basic} storybook="components-elements-avatar-group--basic" />

## Theme Customization
AvatarGroup supports theming to ensure its appearance aligns with the overall design of your application.
The default theme settings include:

<ThemeRender theme={avatarGroupTheme} />

Learn more about how to customize in the [Theme documentation](/docs/theme/getting-started).

## API
Customization options available through the AvatarGroup component's properties:
<PropsTable name="AvatarGroup" />

## Design and Usability Tips

- **Expandable Details:** Provide a mechanism (e.g., tooltip or modal) to view all avatars in a group on click or hover, ensuring users can access every member's profile without cluttering the UI.
- **Customizable Views:** Allow users to customize the visibility and ordering of avatars in a group, accommodating personal preferences and improving the experience.

================
File: src/pages/docs/components/elements/avatar.mdx
================
import { Canvas, Meta } from '@storybook/blocks';
import * as AvatarStories from '../../../../stories/components/Avatar.story.tsx';
import { avatarTheme } from 'reablocks';
import { PropsTable } from '@/components/ui/props-table';
import ThemeRender from '@/components/ui/theme-render';
import { ToggleCanvas } from '@/components/ui/toggle-canvas';
import { Runner } from '@/components/ui/runner';

<Meta of={AvatarStories} />

# Avatar

The "Avatar" component is a versatile UI element designed to display visual identifiers for users, such as profile pictures or initials.
It's widely used across applications to personalize user experiences, especially in sections related to user profiles, comments, or team pages.

## Quick Start
To start using the `Avatar` component, import it from the `reablocks` library and provide the `name` prop.

<Runner code={`import { Avatar } from 'reablocks';

export default function App() {
  return <Avatar name="Teddy Roosevelt" />
}`}
/>

## Examples
### Basic Usage
#### Displaying User Initials
The Avatar component can automatically generate and display initials based on the user's name.
For names comprising multiple words, it uses the first letter of each word. For single-word names, only the first letter is displayed:
<ToggleCanvas of={AvatarStories.Simple} storybook="components-elements-avatar--simple" />

#### Displaying Profile Pictures
When a URL to a user's profile picture is available,
the Avatar component can display the image within a circular frame, adhering to the common design pattern for user avatars:
<ToggleCanvas of={AvatarStories.RoundedWithImage} storybook="components-elements-avatar--rounded-with-image" />

## Theme Customization
The Avatar component comes with a default theme that can be customized.
The base theme includes styles for center alignment, background cover, and text styling, with an option to make the avatar rounded:

<ThemeRender theme={avatarTheme} />

Learn more about how to customize in the [Theme documentation](/docs/theme/getting-started).

## API
Customize the Avatar component through the following properties:
<PropsTable name="Avatar" />

## Design and Usability Tips

- **Optimal Resolution:** For user avatars, ensure that images are displayed at an optimal resolution to maintain visual clarity without unnecessarily burdening the page load times.
Consider implementing a standard size for avatars across your application to create a consistent and professional appearance.

================
File: src/pages/docs/components/elements/badge.mdx
================
import { Canvas, Meta } from '@storybook/blocks';
import * as BadgeStories from '../../../../stories/components/Badge.story.tsx';
import { badgeTheme } from 'reablocks';
import { PropsTable } from '@/components/ui/props-table';
import { ToggleCanvas } from '@/components/ui/toggle-canvas';
import ThemeRender from '@/components/ui/theme-render';
import { Runner } from '@/components/ui/runner';

<Meta of={BadgeStories} />

# Badge
The `Badge` component serves as a small count and labeling tool that overlays its content on another
element, typically used for displaying notifications, status, or additional info like new messages or
alerts. It's designed to draw attention to specific elements by showing relevant numbers or indicators.

## Quick Start
To start using the `Badge` component, import it from the `reablocks` library and provide the `content` prop.

<Runner code={`import { Badge } from 'reablocks';

export default function App() {
  return <Badge content="9" />
}`}
/>

## Examples
### Basic Usage (Color Variations)
The Badge component can be styled with various colors to indicate different statuses or priorities.
Here's how to display badges with default, primary, secondary, and error color schemes:
<ToggleCanvas of={BadgeStories.Colors} storybook="components-elements-badge--colors" />

### Advanced Usage (Position Variations)
The position of a Badge relative to its child component can be customized to appear in various locations like `top-start`, `top-end`, `bottom-start`, and `bottom-end`:
<ToggleCanvas of={BadgeStories.Positions} storybook="components-elements-badge--positions" />

## Theme Customization
The Badge component comes with a default theme that can be customized according to your application's design system:

<ThemeRender theme={badgeTheme} />

Learn more about how to customize in the [Theme documentation](/docs/theme/getting-started).

## API
Customize the Badge component through the following properties:
<PropsTable name="Badge" />

## Design and Usability Tips

- **Visibility at a Glance:** Design badges to be easily scannable, using minimal text or numbers and high-contrast colors to stand out from their background.
- **Avoid Overuse:** Use badges sparingly within the interface to prevent dilution of their significance; too many badges can overwhelm users and diminish their attention-grabbing effect.

================
File: src/pages/docs/components/elements/button.mdx
================
import { Canvas, Meta } from '@storybook/blocks';
import { Cards } from 'nextra/components'
import * as ButtonStories from '../../../../stories/components/Button.story.tsx';
import * as ButtonGroupStories from '../../../../stories/components/ButtonGroup.story.tsx';
import { buttonTheme } from 'reablocks';
import { PropsTable } from '@/components/ui/props-table';
import ThemeRender from '@/components/ui/theme-render';
import { ToggleCanvas } from '@/components/ui/toggle-canvas';
import { Runner } from '@/components/ui/runner';

<Meta of={ButtonStories} />
<Meta of={ButtonGroupStories} />

# Button
The `Button` component is a fundamental UI element designed for interactions, offering a variety of styles, sizes, and colors to accommodate different use cases within an application.
Additionally, a "ButtonGroup" is provided to layout multiple buttons in a cohesive unit, enhancing the visual consistency and usability of grouped actions.

## Quick Start
To start using the `Button` component, import it from the `reablocks` library.

<Runner code={`import { Button } from 'reablocks';

export default function App() {
  return <Button>Click Me</Button>
}`}
/>

## Examples
### Basic Usage
The Button component supports several variants including "filled", "outline", and
"text", allowing for flexibility in design and application:

<ToggleCanvas of={ButtonStories.Variants} storybook="components-elements-button--variants" />

```javascript
{
  variants: {
    filled: "bg-gray-800 text-white hover:bg-gray-700 border-gray-800",
    outline: "bg-opacity-0 border-grey border",
    text: "bg-opacity-0 border-0"
  }
}
```

### Advanced Customization
#### Sizes and Colors
Buttons can be customized further with size and color variations, providing a wide range of
styling options to match your UI design:

<ToggleCanvas of={ButtonStories.Sizes} storybook="components-elements-button--sizes" />

Theme customization can be used to define the size variations for different button sizes:

```javascript
{
    sizes: {
      small: 'text-sm px-2 py-1 leading-[normal]',
      medium: 'text-base px-4 py-2 leading-[normal]',
      large: 'text-xl px-5 py-2.5 leading-[normal]'
    }
    iconSizes: {
      small: 'p-1',
      medium: 'p-2',
      large: 'p-2.5'
    }
}
```

<ToggleCanvas of={ButtonStories.Colors} storybook="components-elements-button--colors" />

Theme customization can be used to define the color variations for different button types. This includes extending the default colors with custom colors:

```javascript
{
    colors: {
      default: {
        filled: 'bg-gray-800 hover:bg-gray-700 border-gray-800',
        outline: 'border-secondary border',
        text: 'text-surface-content'
      },
      primary: {
        filled:
          'bg-primary hover:bg-primary-hover border-primary text-surface-content',
        outline: 'border border-primary',
        text: 'text-primary hover:text-primary-hover'
      },
      secondary: {
        filled:
          'bg-secondary hover:bg-secondary-hover border-secondary text-surface-content',
        outline: 'border border-secondary',
        text: 'text-secondary hover:text-secondary-hover'
      },
      success: {
        filled:
          'bg-success hover:bg-success-hover border-success text-surface-content',
        outline: 'border border-success',
        text: 'text-success hover:text-success-hover'
      },
      warning: {
        filled:
          'bg-warning hover:bg-warning-hover border-warning text-surface-content',
        outline: 'border border-warning',
        text: 'text-warning hover:text-warning-hover'
      },
      error: {
        filled: 'bg-error hover:bg-error-hover border-error text-surface-content',
        outline: 'border border-error',
        text: 'text-error hover:text-error-hover'
      },
      // custom color e.g. pink
      pink: {
        filled: 'bg-pink-500 hover:bg-pink-500-hover border-pink-500 text-surface-content',
        outline: 'border border-pink-500',
        text: 'text-pink-500 hover:text-pink-500-hover'
      }
    }
}
```

#### Buttons with Icon
Incorporating icons with text can enhance button functionality and user understanding:

<ToggleCanvas of={ButtonStories.WithIcon} storybook="components-elements-button--with-icon" />

Theme customization can be used to define the icon size and padding for different button sizes:

```javascript
{
    adornment: {
    base: "flex",
    start: "pr-1",
    end: "pl-1",
    sizes: {
      small: "[&>svg]:w-3 [&>svg]:h-3",
      medium: "[&>svg]:w-4 [&>svg]:h-4",
      large" "[&>svg]:w-5 [&>svg]:h-5"
    }
  }
}
```

#### Group of Buttons
The ButtonGroup component allows for organizing multiple buttons together, which is particularly useful for related actions:
<ToggleCanvas of={ButtonGroupStories.Colors} storybook="components-elements-button-group--colors" />

### Blocks
This component is used in the following Blocks:

<Cards>
  <Cards.Card title="Forgot Password" href="/blocks/authentication/forgot-password" />
  <Cards.Card title="Login" href="/blocks/authentication/login" />
  <Cards.Card title="MFA" href="/blocks/authentication/mfa" />
  <Cards.Card title="Register" href="/blocks/authentication/register" />
  <Cards.Card title="Not Found" href="/blocks/foundation/not-found" />
  <Cards.Card title="Contact" href="/blocks/foundation/contact" />
  <Cards.Card title="Billing" href="/blocks/administration/billing" />
  <Cards.Card title="Pricing" href="/blocks/administration/pricing" />
  <Cards.Card title="Team" href="/blocks/administration/team" />
</Cards>

## Theme Customization
The Button component comes with a default theme that can be customized for consistency with your application's design language:

<ThemeRender theme={buttonTheme} />

Learn more about how to customize in the [Theme documentation](/docs/theme/getting-started).

## API
Customize the `Button` and `ButtonGroup` components through the following properties:
### Button
<PropsTable name="Button" />

### ButtonGroup
<PropsTable name="ButtonGroup" />

## Design and Usability Tips

- **Focus Indicators:** Maintain visible focus indicators for keyboard navigation, aiding in accessibility and indicating the current interactive element to users.
- **Efficient Space Use:** Optimize button sizes and padding to use space efficiently while ensuring touch targets meet accessibility standards (minimum 44x44 pixels).

================
File: src/pages/docs/components/elements/chip.mdx
================
import { Canvas, Meta } from '@storybook/blocks';
import { Cards } from 'nextra/components'
import * as ChipStories from '../../../../stories/components/Chip.story.tsx';
import { chipTheme } from 'reablocks';
import { PropsTable } from '@/components/ui/props-table';
import { ToggleCanvas } from '@/components/ui/toggle-canvas';
import ThemeRender from '@/components/ui/theme-render';
import { Runner } from '@/components/ui/runner';

<Meta of={ChipStories} />

# Chip
The `Chip"` component is a versatile UI element commonly used for displaying tags, labels, statuses, or categories. It's highly customizable, enabling the use of different types, colors, sizes, and even adornments like icons.
Chips can be interactive, allowing for selection or removal, making them suitable for various applications from filtering content to showing user selections.

## Quick Start
To start using the `Chip` component, import it from the `reablocks` library.

<Runner code={`import { Chip } from 'reablocks';

export default function App() {
  return <Chip>Active</Chip>
}`}
/>

## Examples
### Basic Usage
The Chip component supports several style variants such as "filled" and "outline".
This allows for clear differentiation between different chip types based on their
purpose or context within the UI:

<ToggleCanvas of={ChipStories.Variants} storybook="components-elements-chip--variants" />

### Advanced Customization
#### Colors and Sizes
Chips can be customized further in terms of color and size, providing flexibility to
match them with the application's design theme:

<ToggleCanvas of={ChipStories.Colors} storybook="components-elements-chip--colors" />

<ToggleCanvas of={ChipStories.Sizes} storybook="components-elements-chip--sizes" />

#### Icon Adornment
Adding icons to chips enhances visual communication and can indicate additional functionalities like deletion or selection:
<ToggleCanvas of={ChipStories.Adornment} storybook="components-elements-chip--adornment" />

#### Selectable Chips
Chips can be made selectable, allowing users to choose one or more options from a set:
<ToggleCanvas of={ChipStories.Selectable} storybook="components-elements-chip--selectable" />

### Blocks
This component is used in the following Blocks:

<Cards>
  <Cards.Card title="Not Found" href="/blocks/foundation/not-found" />
  <Cards.Card title="Billing" href="/blocks/administration/billing" />
  <Cards.Card title="Pricing" href="/blocks/administration/pricing" />
  <Cards.Card title="Profile" href="/blocks/administration/profile" />
</Cards>

## Theme Customization
The Chip component comes with a default theme, which can be customized according to your application's design requirements:

<ThemeRender theme={chipTheme} />

Learn more about how to customize in the [Theme documentation](/docs/theme/getting-started).

## API
Customize the Chip component using the following properties:
<PropsTable name="Chip" />

## Design and Usability Tips

- **Dynamic Interaction:** For chips representing dynamic content (like filters), provide immediate visual feedback when the state changes (e.g., through animation) to reflect the action's impact.
- **Accessibility Enhancements:** Beyond color, utilize shapes or icons within chips to communicate status or category for those with color vision deficiencies.

================
File: src/pages/docs/components/elements/command-palette.mdx
================
import { Canvas, Meta } from '@storybook/blocks';
import * as CommandPaletteStories from '../../../../stories/components/CommandPalette.story.tsx';
import { commandPaletteTheme } from 'reablocks';
import { PropsTable } from '@/components/ui/props-table';
import { ToggleCanvas } from '@/components/ui/toggle-canvas';
import ThemeRender from '@/components/ui/theme-render';

<Meta of={CommandPaletteStories} />

# Command Palette
The Command Palette enables efficient user interaction by consolidating application commands in a searchable, centralized interface.
It's akin to a spotlight search, providing immediate access to features, documents, settings, or actions directly from the keyboard.

## Examples
### Basic Usage
This example showcases a basic Command Palette setup with sections for "Recently Used" commands and "Suggestions":
<ToggleCanvas of={CommandPaletteStories.Simple} storybook="components-data-command-palette--simple" />

## Theme Customization
The default theme for the Command Palette is designed for clarity and ease of use,
but can be customized to match your application's design language:

<ThemeRender theme={commandPaletteTheme} />

Learn more about how to customize in the [Theme documentation](/docs/theme/getting-started).

## API
Customize the Command Palette through the following properties:
<PropsTable name="CommandPalette" />

## Design and Usability Tips
- **Intuitive Access:** Ensure the Command Palette is easily accessible through a well-known keyboard shortcut (e.g., Cmd/Ctrl + P), making it discoverable and convenient.
- **Clear Categorization:** Organize commands into clear categories or sections to help users quickly find what they need.

================
File: src/pages/docs/components/elements/icon-button.mdx
================
import { Canvas, Meta } from '@storybook/blocks';
import * as IconButtonStories from '../../../../stories/components/IconButton.story.tsx';
import { buttonTheme } from 'reablocks';
import { PropsTable } from '@/components/ui/props-table';
import { ToggleCanvas } from '@/components/ui/toggle-canvas';
import ThemeRender from '@/components/ui/theme-render';
import { Runner } from '@/components/ui/runner';

<Meta of={IconButtonStories} />

# IconButton
The IconButton component integrates icons within buttons, combining the visual appeal of icons with the functionality of buttons.
This component is crucial for creating intuitive and space-efficient user interfaces, especially in applications requiring a clean and modern aesthetic.

## Quick Start
To start using the `IconButton` component, import it from the `reablocks` library.

<Runner code={`import { IconButton } from 'reablocks';

export default function App() {
  return <IconButton>©</IconButton>
}`}
/>

## Examples
### Basic Usage
#### Icon Buttons with Type Variations
The `IconButton` component integrates icons into buttons, providing various style variants like "filled", "outline", and "text".
These options allow for versatile use across your UI, depending on the intended visual impact and user interaction:
<ToggleCanvas of={IconButtonStories.Variants} storybook="components-elements-iconbutton--variants" />

### Advanced Customization
#### Icon Buttons with Color Variations
`IconButton` supports different color schemes to signify various actions or statuses, enhancing the UX with visual cues.
You can customize the background, icon color, and border to fit your application's design language.
<ToggleCanvas of={IconButtonStories.ColorsBackground} storybook="components-elements-iconbutton--colors-background" />
<ToggleCanvas of={IconButtonStories.ColorsIcons} storybook="components-elements-iconbutton--colors-icons" />
<ToggleCanvas of={IconButtonStories.ColorsOutline} storybook="components-elements-iconbutton--colors-outline" />

#### Icon Buttons with Size Variations
Adjusting the size of `IconButtons` is straightforward, allowing them to fit seamlessly into different parts of your application, from toolbars to forms:
<ToggleCanvas of={IconButtonStories.Sizes} storybook="components-elements-iconbutton--sizes" />


## Theme Customization
Customize the IconButton's appearance with our default theme or your tailored version to ensure it complements your application's style.
Here's the default theme structure:
<ThemeRender theme={buttonTheme} />

Learn more about how to customize in the [Theme documentation](/docs/theme/getting-started).

## API
Each property of the IconButton is detailed below, providing insight into how to fully utilize the component's capabilities.

{/* TODO Incorect DOC for IconButton due to extend with Omit of Button */}
<PropsTable name="Button" />

## Design and Usability Tips
- **Accessibility Considerations:** Ensure that `IconButtons` are accessible by providing appropriate `aria-labels` for screen readers.
Icons might convey meaning visually, but without proper labels, they can be meaningless or confusing to visually impaired users.

- **Spacing and Sizing for Touch:** Consider the touch target size, especially for touch-screen device users.
Ensure `IconButtons` are large enough to be easily tapped without accidentally activating neighboring elements.
The recommended minimum touch target size is 48x48 pixels.

================
File: src/pages/docs/components/elements/kbd.mdx
================
import { Canvas, Meta } from '@storybook/blocks';
import * as KbdStories from '../../../../stories/components/Kbd.story.tsx';
import { kbdTheme } from 'reablocks';
import { PropsTable } from '@/components/ui/props-table';
import { ToggleCanvas } from '@/components/ui/toggle-canvas';
import ThemeRender from '@/components/ui/theme-render';
import { Runner } from '@/components/ui/runner';

<Meta of={KbdStories} />

# Kbd
The Kbd (Keyboard Shortcut Chip) component is designed to visually represent keyboard shortcuts within your web application.
It's particularly useful for highlighting shortcuts on hover over UI elements or integrating with command-driven features like the [Command Palette](/docs/components/elements/command-palette) component.

## Quick Start
To start using the `Kbd` component, import it from the `reablocks` library and provide the `keycode` prop.

<Runner code={`import { Kbd } from 'reablocks';

export default function App() {
  return <Kbd keycode="option+m"></Kbd>
}`}
/>

## Examples
### Basic Usage
Showcase keyboard shortcuts effectively to enhance usability and provide quick access to application functionalities.
<ToggleCanvas of={KbdStories.Basic} storybook="components-elements-kbd--basic" />

## Theme Customization
The Kbd component comes with a default theme designed for clarity and readability. Customize this theme to align with your application's aesthetics and branding:

<ThemeRender theme={kbdTheme} />

Learn more about how to customize in the [Theme documentation](/docs/theme/getting-started).

## API
The Kbd component API is straightforward, focusing on the essential functionality of displaying keyboard shortcuts:
<PropsTable name="Kbd" />

## Design and Usability Tips

- **Clear Formatting:** Ensure keyboard shortcuts are displayed in a clear, easily understood format.
Use symbols and abbreviations recognized by most users (e.g., "Cmd" for Command, "Ctrl" for Control).

- **Strategic Positioning:** Place Kbd components where they are most relevant within your UI.
Consider proximity to the related action or feature to help users make the connection between the shortcut and its function.

================
File: src/pages/docs/components/elements/loader.mdx
================
import { Canvas, Meta } from '@storybook/blocks';
import * as DotsLoaderStories from '../../../../stories/components/DotsLoader.story.tsx';
import { dotsLoaderTheme } from 'reablocks';
import { PropsTable } from '@/components/ui/props-table';
import { ToggleCanvas } from '@/components/ui/toggle-canvas';
import ThemeRender from '@/components/ui/theme-render';
import { Runner } from '@/components/ui/runner';

<Meta of={DotsLoaderStories} />

# Loader
The Loader component acts as a visual placeholder, signaling to users that data is being loaded or UI components are in the process of rendering.
This component is especially crucial for enhancing user experience during initial page loads or data fetching processes, reducing perceived wait times through engaging animations.

## Quick Start
To start using the `DotsLoader` component, import it from the `reablocks` library.

<Runner code={`import { DotsLoader } from 'reablocks';

export default function App() {
  return <DotsLoader />
}`}
/>

### Basic Usage

Employ the Loader to maintain user engagement during wait times. Here's how to integrate a simple `DotsLoader` into your application:
<ToggleCanvas of={DotsLoaderStories.Simple} storybook="components-elements-loader-dots--simple" />

## Theme Customization

Tailor the Loader's appearance to fit your application's aesthetic with our customizable theme options.
The default theme includes flexible settings for base alignment, dot style, and size variations:
<ThemeRender theme={dotsLoaderTheme} />

Learn more about how to customize in the [Theme documentation](/docs/theme/getting-started).

## API

Optimize the Loader's functionality and style to meet your specific requirements with these configurable properties:
<PropsTable name="DotsLoader" />

## Design and Usability Tips

- **Visibility:** Place the Loader in a central, visible location to reassure users that the application is actively processing their request.

- **Contextual Use:** Select Loader sizes and speeds appropriate to the context.
For example, use smaller, faster loaders for inline loading states, and larger, more deliberate animations for page-wide loads.

================
File: src/pages/docs/components/form/calendar.mdx
================
import { Canvas, Meta } from '@storybook/blocks';
import * as CalendarStories from '../../../../stories/components/Calendar.story.tsx';
import { calendarTheme } from 'reablocks';
import { PropsTable } from '@/components/ui/props-table';
import { ToggleCanvas } from '@/components/ui/toggle-canvas';
import ThemeRender from '@/components/ui/theme-render';

<Meta of={CalendarStories} />

# Calendar
The Calendar component is a versatile UI tool designed for date selection within web applications.
It can be utilized independently or integrated with other UI elements like search boxes to define time ranges for various actions.
This component is pivotal in applications requiring date inputs, such as booking systems, event planners, and analytics dashboards.

## Examples
### Basic Usage
This example demonstrates a simple calendar allowing for a single date selection, updating a display with the selected date or indicating when no date is chosen:
<ToggleCanvas of={CalendarStories.Simple} storybook="components-form-calendar--simple" />

### Advanced Customization
#### Date Range Selection
Enable users to select a range of dates, useful for applications requiring start and end date inputs:
<ToggleCanvas of={CalendarStories.Range} storybook="components-form-calendar--range" />

#### Restricted Date Range
Limit selection within a specific date range, enhancing usability by preventing invalid date choices:
<ToggleCanvas of={CalendarStories.MinMax} storybook="components-form-calendar--min-max" />

### Initialize with Default Date
Automatically set the calendar to a specific date upon initialization, such as one month from the current date, guiding users towards a default selection:
<ToggleCanvas of={CalendarStories.DefaultValue} storybook="components-form-calendar--default-value" />

### Day of week labels
Enhance usability by displaying day-of-week labels, offering users a clearer context for date selection. This variant is particularly useful for scheduling or planning applications where the day of the week is a critical factor:
<ToggleCanvas of={CalendarStories.WithLabels} storybook="components-form-calendar--with-labels" />

### Range Selection
Implement range selection functionality within the calendar for scenarios requiring a start and end date, such as booking periods or event planning. This feature enhances the component's flexibility, accommodating a broader range of use cases:
<ToggleCanvas of={CalendarStories.Range} storybook="components-form-calendar--range" />

### Multiview Calendar
Showcase a multiview calendar for comparing dates across multiple months simultaneously. This variant is exceptionally beneficial for long-term planning or date comparisons, providing a comprehensive overview of available dates:
<ToggleCanvas of={CalendarStories.Multiview} storybook="components-form-calendar--multiview" />

## Theme Customization
The Calendar component comes with a default theme designed for adaptability and ease of integration:
<ThemeRender theme={calendarTheme} />

Learn more about how to customize in the [Theme documentation](/docs/theme/getting-started).

## API
Optimize the Calendar component with a comprehensive set of configurable properties:
<PropsTable name="Calendar" />

## Design and Usability Tips

- **Efficient Navigation:** Ensure the calendar supports comprehensive keyboard navigation, enabling users to select dates without mouse interaction, crucial for accessibility and power users.

================
File: src/pages/docs/components/form/checkbox.mdx
================
import { Canvas, Meta } from '@storybook/blocks';
import * as CheckboxStories from '../../../../stories/components/Checkbox.story.tsx';
import { checkboxTheme } from 'reablocks';
import { PropsTable } from '@/components/ui/props-table';
import { ToggleCanvas } from '@/components/ui/toggle-canvas';
import ThemeRender from '@/components/ui/theme-render';

<Meta of={CheckboxStories} />


# Checkbox
The Checkbox component is an essential element in UI/UX design, allowing users to make selections among a set of options.
It enhances user control by enabling or disabling specific choices, thereby facilitating interactive and dynamic forms, settings, and controls within applications.
## Examples
### Basic Usage
This basic example showcases a checkbox that users can click to enable or disable an option. It demonstrates the component's primary functionality - toggling between checked and unchecked states:
<ToggleCanvas of={CheckboxStories.Simple} storybook="components-form-checkbox--simple" />

### Advanced Customization
#### Size Variations
Customize the size of the Checkbox to match the design requirements of your application, offering variations like small, medium, and large for better visual integration and user experience:
<ToggleCanvas of={CheckboxStories.Sizes} storybook="components-form-checkbox--sizes" />

### State Variations
Implement checkboxes with additional states such as disabled for non-interactive scenarios and intermediate for partially selected groups or indeterminate states:
<ToggleCanvas of={CheckboxStories.States} storybook="components-form-checkbox--states" />

## Theme Customization
The Checkbox component features a default theme that can be customized to align with your application's aesthetics. Here's an overview of the theme structure:

<ThemeRender theme={checkboxTheme} />

Learn more about how to customize in the [Theme documentation](/docs/theme/getting-started).

## API
Fine-tune the Checkbox component's functionality and style with a wide array of configurable properties:
<PropsTable name="Checkbox" />

## Design and Usability Tips
- **Visual Clarity:** Ensure checkboxes are large enough to be easily tapped on touch devices, adhering to accessible design principles. A minimum touch target size of 44x44 pixels is recommended. This enhances usability across various devices, particularly for users with motor impairments.
- **Label Legibility:** Accompany every checkbox with a clear and concise label. Labels should be directly clickable to toggle the checkbox state, reducing the precision required for interaction and thus improving the overall user experience.

================
File: src/pages/docs/components/form/date-input.mdx
================
import { Canvas, Meta } from '@storybook/blocks';
import * as DateInputStories from '../../../../stories/components/DateInput.story.tsx';
import { PropsTable } from '@/components/ui/props-table';
import { ToggleCanvas } from '@/components/ui/toggle-canvas';

<Meta of={DateInputStories} />

# Date Input
A visual way to choose a date using a calendar view and input box.

## Examples
<ToggleCanvas of={DateInputStories.Simple} storybook="components-form-date-input--simple" />

## API
### Component
<PropsTable name="DateInput" />

================
File: src/pages/docs/components/form/debounced-input.mdx
================
import { Canvas, Meta } from '@storybook/blocks';
import * as InputStories from '../../../../stories/components/DebouncedInput.story.tsx';
import { checkboxTheme } from 'reablocks';
import { PropsTable } from '@/components/ui/props-table';
import { ToggleCanvas } from '@/components/ui/toggle-canvas';

<Meta of={InputStories} />

# Debounced Input
The Debounced Input component is designed to optimize user input in applications by delaying the processing of text after a specified duration.
This feature is particularly useful in scenarios where real-time input processing may be resource-intensive, such as live search functionalities or validations.
## Examples
### Basic Usage
This example illustrates the use of Debounced Input for both immediate and delayed text processing.
Instant input processes text changes immediately, while delayed input waits for a specified duration before processing the text, minimizing unnecessary computations or API calls:
<ToggleCanvas of={InputStories.Basic} storybook="components-form-debounced-input--basic" />

## API
The Debounced Input component offers several configurable properties to tailor its functionality and appearance to suit your application's needs:
<PropsTable name="DebouncedInput" />

## Design and Usability Tips
- **Visual Feedback:** Implement visual cues to indicate when the input is being processed or debounced, such as a loader icon or changing the input border color. This feedback reassures users that their input is recognized and will be processed shortly.
- **Adaptive Debouncing:** Dynamically adjust the debounce duration based on the use case. For example, increase the duration for live search functionalities to reduce server load, but keep it minimal for local validations to maintain responsiveness.

================
File: src/pages/docs/components/form/inline-input.mdx
================
import { Canvas, Meta } from '@storybook/blocks';
import * as InlineInputStories from '../../../../stories/components/InlineInput.story.tsx';
import { PropsTable } from '@/components/ui/props-table';
import { ToggleCanvas } from '@/components/ui/toggle-canvas';

<Meta of={InlineInputStories} />

# Inline Input
The Inline Input component is tailored for inline editing scenarios, offering a fluid and responsive input field that expands in response to user input.
This component is ideally suited for applications requiring seamless inline text modifications without the cumbersome overhead of traditional form inputs.
## Examples
### Basic Usage
This example demonstrates the Inline Input in action, providing a user-friendly editing experience within a bordered container.
The input field automatically adjusts its size as the user types, accommodating the entered text while maintaining a compact UI footprint:
<ToggleCanvas of={InlineInputStories.Basic} storybook="components-form-inline-input--basic" />

## API
Configure the Inline Input component to fit your specific inline editing needs with these properties:
<PropsTable name="InlineInput" />

## Design and Usability Tips

- **Responsive Behavior:** Test the Inline Input component across various device sizes and screen resolutions to guarantee a consistent and usable experience.
Inline editing elements should remain functional and visually coherent even on smaller screens, where space is at a premium.

================
File: src/pages/docs/components/form/input.mdx
================
import { Canvas, Meta } from '@storybook/blocks';
import { Cards } from 'nextra/components'
import * as InputStories from '../../../../stories/components/Input.story.tsx';
import { inputTheme } from 'reablocks';
import { PropsTable } from '@/components/ui/props-table';
import { ToggleCanvas } from '@/components/ui/toggle-canvas';
import ThemeRender from '@/components/ui/theme-render';

<Meta of={InputStories} />

# Input
The Input component is a fundamental element in form design, allowing users to enter data.
Its versatility supports a variety of applications, from simple text entries to complex data inputs.

## Examples
### Basic Usage
A straightforward implementation of the Input component for basic text entry:
<ToggleCanvas of={InputStories.Basic} storybook="components-form-input--basic" />

### Advanced Customization
#### Size Variations
Adjust the size of the input field (small, medium, large) to accommodate different content lengths and interface designs:
<ToggleCanvas of={InputStories.Sizes} storybook="components-form-input--sizes" />

#### Full Width
Extend the input field to the full width of its container, ideal for forms or sections requiring larger text entries:
<ToggleCanvas of={InputStories.FullWidth} storybook="components-form-input--full-width" />

#### Adornments at Start/End
Enhance input fields with icons or text at the start or end to provide context or additional functionalities:
<ToggleCanvas of={InputStories.StartEndAdorment} storybook="components-form-input--start-end-adorment" />

#### State Variations
Implement variations for error states and disabled inputs, providing visual feedback and interaction cues.

- **Error**
<ToggleCanvas of={InputStories.Error} storybook="components-form-input--error" />
- **Disabled**
<ToggleCanvas of={InputStories.Disabled} storybook="components-form-input--disabled" />

### Value Initialization
Set initial values or placeholders to guide user input or display default values:
- **Placeholder**
<ToggleCanvas of={InputStories.Placeholder} storybook="components-form-input--placeholder" />
- **Default value**
<ToggleCanvas of={InputStories.DefaultValue} storybook="components-form-input--default-value" />

### Blocks
This component is used in the following Blocks:

<Cards>
  <Cards.Card title="Forgot Password" href="/blocks/authentication/forgot-password" />
  <Cards.Card title="Login" href="/blocks/authentication/login" />
  <Cards.Card title="MFA" href="/blocks/authentication/mfa" />
  <Cards.Card title="Register" href="/blocks/authentication/register" />
  <Cards.Card title="Not Found" href="/blocks/foundation/not-found" />
  <Cards.Card title="Contact" href="/blocks/foundation/contact" />
  <Cards.Card title="MFA" href="/blocks/authentication/mfa" />
  <Cards.Card title="Profile" href="/blocks/administration/profile" />
</Cards>

## Theme Customization
Customize the Input component's appearance to align with your application's theme:
<ThemeRender theme={inputTheme} />

Learn more about how to customize in the [Theme documentation](/docs/theme/getting-started).

## API
Fine-tune the Input component's behavior and appearance with these configurable properties:
<PropsTable name="Input" />

## Design and Usability Tips

- **Consistent Field Width:** Design input fields with a width that hints at the expected length of the answer. For example, shorter fields for postal codes or longer fields for descriptions. This visual cue helps users gauge the expected input at a glance.
- **Error State Feedback:** Clearly indicate error states through text messages. Place error messages close to the related input field, and ensure they provide constructive feedback on how to resolve the issue.

================
File: src/pages/docs/components/form/radio.mdx
================
import { Canvas, Meta } from '@storybook/blocks';
import * as RadioStories from '../../../../stories/components/Radio.story.tsx';
import * as RadioGroupStories from '../../../../stories/components/RadioGroup.story.tsx';
import { radioTheme } from 'reablocks';
import { PropsTable } from '@/components/ui/props-table';
import { ToggleCanvas } from '@/components/ui/toggle-canvas';
import ThemeRender from '@/components/ui/theme-render';

<Meta of={RadioStories} />
<Meta of={RadioGroupStories} />

# Radio

Radio elements play a crucial role in UI/UX design by facilitating exclusive selection among a set of options.
This ensures that users can choose only one item from a list, streamlining clear decision-making processes and providing enhanced control.
## Examples
### Basic Usage
Illustrates a singular Radio button allowing users to make a choice with a simple click:
<ToggleCanvas of={RadioStories.Simple} storybook="components-form-radio--simple" />

### Advanced Customization
#### Size Variations
Showcases Radio buttons in different sizes: small, medium, and large, accommodating various design needs and enhancing UI flexibility:
<ToggleCanvas of={RadioStories.Sizes} storybook="components-form-radio--sizes" />

#### Disabled state
Demonstrates a Radio button in a disabled state, indicating non-interactive periods or conditions within the user interface:
<ToggleCanvas of={RadioStories.Disabled} storybook="components-form-radio--disabled" />

#### Group of Radio Buttons with Single Form Control
A set of Radio buttons grouped together, allowing users to select one option from multiple choices, with a single selected value reflected in the application:
<ToggleCanvas of={RadioGroupStories.Simple} storybook="components-form-radio-group--simple" />

## Theme Customization
The Radio component adheres to the following default theme, ensuring aesthetic consistency and visual appeal:

<ThemeRender theme={radioTheme} />

Learn more about how to customize in the [Theme documentation](/docs/theme/getting-started).

## API
Tailor the Radio component's functionality to meet your project's requirements with a comprehensive set of properties:
### Radio
<PropsTable name="Radio" />

### RadioGroup
<PropsTable name="RadioGroup" />

## Design and Usability Tips

- **Label Legibility:** Ensure that labels associated with radio buttons are clear, concise, and directly related to the options they represent. Labels should be positioned close to the respective radio button to maintain visual connection and prevent ambiguity during selection processes.
- **Distinctive Appearance:** Design radio buttons to be visually distinctive from checkboxes to avoid confusion between multiple-choice and single-choice options. Employ standard design patterns, such as circular radio buttons with a filled circle indicator for the selected state, reinforcing their

================
File: src/pages/docs/components/form/range.mdx
================
import { Canvas, Meta } from '@storybook/blocks';
import * as RangeStories from '../../../../stories/components/Range.story.tsx';
import { rangeTheme } from 'reablocks';
import { PropsTable } from '@/components/ui/props-table';
import { ToggleCanvas } from '@/components/ui/toggle-canvas';
import ThemeRender from '@/components/ui/theme-render';

<Meta of={RangeStories} />

# Range Slider
The Range Slider component empowers users to select a single value or a range of values with ease, enhancing interactive data input within applications.
It's especially useful in scenarios requiring users to define parameters such as price ranges, filters, or any adjustable settings.
## Examples
### Basic Usage
This example illustrates how to implement a Range Slider for selecting a single value, providing a straightforward way for users to specify a precise figure within a defined limit:
<ToggleCanvas of={RangeStories.Single} storybook="components-form-range--single" />

### Advanced Customization
#### Range Selection
Demonstrates a dual-handle Range Slider enabling users to select a range between two values, ideal for defining intervals such as price filters or age brackets:
<ToggleCanvas of={RangeStories.Double} storybook="components-form-range--double" />

## Theme Customization
The Range Slider comes with a default theme that can be customized to fit the aesthetic of any application:

<ThemeRender theme={rangeTheme} />

Learn more about how to customize in the [Theme documentation](/docs/theme/getting-started).

## API
Configure the Range Slider to meet specific needs with these adjustable properties:
### RangeSingle
<PropsTable name="RangeSingle" />

### RangeDouble
<PropsTable name="RangeDouble" />

## Design and Usability Tips

- **Clear Value Indication:** Always display the current value or range selected by the Range Slider prominently near the component. Consider using tooltips that appear while dragging the slider handles for immediate feedback, or dedicated areas adjacent to the slider that update in real time.
- **Step Intervals and Limits:** Define sensible step intervals and min/max limits based on the context in which the Range Slider is used. For instance, a price filter might use whole number steps, while a control requiring precision (like volume adjustment) may benefit from finer gradations.

================
File: src/pages/docs/components/form/select.mdx
================
import { Canvas, Meta } from '@storybook/blocks';
import * as SingleSelectStories from '../../../../stories/components/SingleSelect.story.tsx';
import * as MultiSelectStories from '../../../../stories/components/MultiSelect.story.tsx';
import { selectTheme } from 'reablocks';
import { PropsTable } from '@/components/ui/props-table';
import { ToggleCanvas } from '@/components/ui/toggle-canvas';
import ThemeRender from '@/components/ui/theme-render';

<Meta of={SingleSelectStories} />
<Meta of={MultiSelectStories} />

# Select
The Select component enhances user interaction by allowing the selection of a value or multiple values from a list of options.
It's designed with flexibility in mind, supporting a wide range of features such as:

- Single Select
- Multi Select
- Flexible customization of the components
- Tagging / Creation of options
- Filtering with Fuzzy Search via [fuse.js](https://github.com/reaviz/react-use-fuzzy)
- Highlighting of selected options
- Async Support
- Groups Support
- Animation

## Examples
### Basic Usage
#### Single Select
A straightforward implementation for choosing a single option from a dropdown list:
<ToggleCanvas of={SingleSelectStories.Basic} storybook="components-form-select-single--basic" />
- **Custom Label**
<ToggleCanvas of={SingleSelectStories.CustomLabels} storybook="components-form-select-single--custom-labels" />
- **Create value if not available**
<ToggleCanvas of={SingleSelectStories.Createable} storybook="components-form-select-single--createable" />
- **Values with sections**
<ToggleCanvas of={SingleSelectStories.Groups} storybook="components-form-select-single--groups" />
- **State: Error**
<ToggleCanvas of={SingleSelectStories.Error} storybook="components-form-select-single--error" />
- **State: Full Width**
<ToggleCanvas of={SingleSelectStories.FluidWidth} storybook="components-form-select-single--fluid-width" />

#### Async
- **Remote Fetch on Load**
<ToggleCanvas of={SingleSelectStories.Async} storybook="components-form-select-single--async" />
- **Async Filtering**
<ToggleCanvas of={SingleSelectStories.AsyncFiltering} storybook="components-form-select-single--async-filtering" />

#### Multi-Select
Allows users to select multiple options, ideal for filtering mechanisms or gathering multiple interests/preferences.
<ToggleCanvas of={MultiSelectStories.Basic} storybook="components-form-select-multi--basic" />


## Theme Customization
The Select component adheres to a comprehensive theme, ensuring it seamlessly integrates into any application's design:

<ThemeRender theme={selectTheme} />

Learn more about how to customize in the [Theme documentation](/docs/theme/getting-started).

## API
Configure the Select component to suit your application's needs with these properties:
### Select
<PropsTable name="Select" />

### SelectOption
<PropsTable name="SelectOption" />

### SelectMenu
<PropsTable name="SelectMenu" />

### SelectInput
<PropsTable name="SelectInput" />

### SelectInputChip
<PropsTable name="SelectInputChip" />

## Design and Usability Tips

- **Immediate Feedback:** Provide visual cues for actions such as hovering, selection, and focusing, enhancing the user's interaction with the component.
- **Keyboard Navigation:** Support full keyboard navigation including arrow keys for option selection and Esc to close the dropdown, ensuring accessibility.

================
File: src/pages/docs/components/form/textarea.mdx
================
import { Canvas, Meta } from '@storybook/blocks';
import { Cards } from 'nextra/components'
import * as TextareaStories from '../../../../stories/components/Textarea.story.tsx';
import { textareaTheme } from 'reablocks';
import { PropsTable } from '@/components/ui/props-table';
import { ToggleCanvas } from '@/components/ui/toggle-canvas';
import ThemeRender from '@/components/ui/theme-render';

<Meta of={TextareaStories} />

# Textarea
The Textarea component is designed for inputting and editing multiline text, making it a crucial element for forms, comments, feedback submissions, and any application requiring comprehensive text input.
It provides a flexible, space-efficient solution for capturing extensive user inputs in a user-friendly manner.

## Examples
### Basic Usage
A minimal setup for a Textarea component, providing users with a straightforward multiline text input field:
<ToggleCanvas of={TextareaStories.Basic} storybook="components-form-textarea--basic" />
### Advanced Customization
#### Size Variations
This example showcases how to adjust the size of the Textarea component to accommodate different content lengths and interface designs, with small, medium, and large options:
<ToggleCanvas of={TextareaStories.Sizes} storybook="components-form-textarea--sizes" />
### States
Illustrates the Textarea component in various states such as disabled, auto-focus, error indication, and full-width styling to demonstrate its versatility in different UI contexts:
- **Disabled**
<ToggleCanvas of={TextareaStories.Disabled} storybook="components-form-textarea--disabled" />
- **Auto Focus**
<ToggleCanvas of={TextareaStories.AutoFocus} storybook="components-form-textarea--auto-focus" />
- **Error**
<ToggleCanvas of={TextareaStories.Error} storybook="components-form-textarea--error" />
- **Full Width**
<ToggleCanvas of={TextareaStories.FullWidth} storybook="components-form-textarea--full-width" />

#### Value Initialization
Demonstrates setting a default value and placeholder text in the Textarea, guiding users with pre-populated content or prompting input with instructional text:
- **Default value**
<ToggleCanvas of={TextareaStories.DefaultValue} storybook="components-form-textarea--default-value" />
- **Placeholder text**
<ToggleCanvas of={TextareaStories.Placeholder} storybook="components-form-textarea--placeholder" />

### Blocks
This component is used in the following Blocks:

<Cards>
  <Cards.Card title="Contact" href="/blocks/foundation/contact" />
  <Cards.Card title="Timeline" href="/blocks/foundation/timeline" />
</Cards>

## Theme Customization
The Textarea component comes with a default theme that can be tailored to fit your application's design requirements:

<ThemeRender theme={textareaTheme} />

Learn more about how to customize in the [Theme documentation](/docs/theme/getting-started).

## API
Fine-tune the Textarea component to suit your application's needs with these configurable properties:
<PropsTable name="Textarea" />

## Design and Usability Tips

- **Animation and Transitions:** Subtle animations, such as on focus or when resizing, can make the interaction with the Textarea more engaging. Ensure animations are smooth and do not detract from the primary function of text input.
- **Adequate Size and Spacing:** Ensure the default size of the Textarea accommodates the average input length to minimize user adjustments. Generous spacing within and around the Textarea helps prevent user errors and makes the text easier to edit.

================
File: src/pages/docs/components/form/toggle.mdx
================
import { Canvas, Meta } from '@storybook/blocks';
import * as ToggleStories from '../../../../stories/components/Toggle.story.tsx';
import { toggleTheme } from 'reablocks';
import { PropsTable } from '@/components/ui/props-table';
import { ToggleCanvas } from '@/components/ui/toggle-canvas';
import ThemeRender from '@/components/ui/theme-render';

<Meta of={ToggleStories} />

# Toggle
The Toggle component is a streamlined interface element that enables users to swiftly switch between two states, such as on/off or enabled/disabled.
It's especially valuable in settings and preference panels for toggling features or modes with a simple click.

## Examples
### Basic Usage
This basic example demonstrates a toggle that users can interact with to switch states. It's a fundamental illustration of the Toggle component's functionality:
<ToggleCanvas of={ToggleStories.Simple} storybook="components-form-toggle--simple" />

### Advanced Customization
#### Toggle Size Variations
Showcase the Toggle component in different sizes—small, medium, and large—to accommodate various design requirements and enhance interface flexibility:
<ToggleCanvas of={ToggleStories.Sizes} storybook="components-form-toggle--sizes" />

#### Disabled Toggle State
Illustrates a Toggle component in a disabled state, which is non-interactive and signifies an option that is temporarily unavailable:
<ToggleCanvas of={ToggleStories.Disabled} storybook="components-form-toggle--disabled" />

## Theme Customization
The Toggle component is designed with a default theme that can be customized to match your application's aesthetic:

<ThemeRender theme={toggleTheme} />

Learn more about how to customize in the [Theme documentation](/docs/theme/getting-started).

## API
Tailor the Toggle component's functionality with a suite of configurable properties:
<PropsTable name="Toggle" />

## Design and Usability Tips

- **Clear State Indication:** Design the Toggle with distinct colors or icons for each state (on/off) to clarify its current status at a glance. This immediate visual feedback is crucial for intuitive interaction.
- **Accessible Labeling:** While the Toggle inherently suggests binary choices, pairing it with accessible, descriptive labels ensures that all users, including those using screen readers, understand the context and implications of the toggle state.

================
File: src/pages/docs/components/layers/backdrop.mdx
================
import { Canvas, Meta } from '@storybook/blocks';
import * as BackdropStories from '../../../../stories/components/Backdrop.story.tsx';
import { PropsTable } from '@/components/ui/props-table';
import { ToggleCanvas } from '@/components/ui/toggle-canvas';

<Meta of={BackdropStories} />

# Backdrop

---

Backdrop is a component that overlays a certain viewport to
prevent users from clicking the bottom layer and draw attention
to the content. This component is typically used with a `Overlay` component.

## API
<PropsTable name="Backdrop" />

================
File: src/pages/docs/components/layers/confirm-dialog.mdx
================
import { Canvas, Meta } from '@storybook/blocks';
import * as DialogStories from '../../../../stories/components/ConfirmDialog.story.tsx';
import { PropsTable } from '@/components/ui/props-table';
import { ToggleCanvas } from '@/components/ui/toggle-canvas';
import ThemeRender from '@/components/ui/theme-render';
import { Runner } from '@/components/ui/runner';

<Meta of={DialogStories} />

# Confirm Dialog
The `ConfirmationDialog` component is a dialog that prompts the user to confirm an action.
It is a wrapper around the `Dialog` component that provides a simple API for creating
confirmation dialogs.

## Examples
<ToggleCanvas of={DialogStories.Default} storybook="components-layers-confirm-dialog--default" />

## API
<PropsTable name="ConfirmDialog" />

================
File: src/pages/docs/components/layers/context-menu.mdx
================
import { Canvas, Meta } from '@storybook/blocks';
import * as ContextMenuStories from '../../../../stories/components/ContextMenu.story.tsx';
import { PropsTable } from '@/components/ui/props-table';
import { ToggleCanvas } from '@/components/ui/toggle-canvas';

<Meta of={ContextMenuStories} />

# Context Menu
The Context Menu component offers contextual options or actions that appear when a user right-clicks an element

## Examples
<ToggleCanvas of={ContextMenuStories.Simple} storybook="components-layers-context-menu--simple" />

## API
<PropsTable name="ContextMenu" />

================
File: src/pages/docs/components/layers/dialog.mdx
================
import { Canvas, Meta } from '@storybook/blocks';
import * as DialogStories from '../../../../stories/components/Dialog.story.tsx';
import { dialogTheme } from 'reablocks';
import { PropsTable } from '@/components/ui/props-table';
import { ToggleCanvas } from '@/components/ui/toggle-canvas';
import ThemeRender from '@/components/ui/theme-render';

<Meta of={DialogStories} />

# Dialog
The Dialog component serves as a pop-up or modal window that overlays the main content,
allowing the display of important messages, forms, or user interactions while grabbing user's focus.

## Examples
### Basic Dialog
<ToggleCanvas of={DialogStories.Simple} storybook="components-layers-dialog--simple" />

### Dialog with Footer and Custom header
<ToggleCanvas of={DialogStories.Footer} storybook="components-layers-dialog--footer" />

## Theme
This component uses the following default theme:

<ThemeRender theme={dialogTheme} />

Learn more about how to customize in the [Theme documentation](/docs/theme/getting-started).

## API
<PropsTable name="Dialog" />

================
File: src/pages/docs/components/layers/drawer.mdx
================
import { Canvas, Meta } from '@storybook/blocks';
import * as DrawerStories from '../../../../stories/components/Drawer.story.tsx';
import { drawerTheme } from 'reablocks';
import { PropsTable } from '@/components/ui/props-table';
import { ToggleCanvas } from '@/components/ui/toggle-canvas';
import ThemeRender from '@/components/ui/theme-render';

<Meta of={DrawerStories} />

# Drawer
The Drawer component provides a hidden or off-canvas panel that can slide in or out from the edge of the screen,
offering additional navigation or content without obstructing the main interface. One common use case is when user
is analysing a list of entries from a table and they quickly wants to see details for some entries.

## Examples
### Basic example
<ToggleCanvas of={DrawerStories.Simple} storybook="components-layers-drawer--simple" />
### Drawer as bottom sheet
<ToggleCanvas of={DrawerStories.BottomSheet} storybook="components-layers-drawer--bottom-sheet" />

## Theme
This component uses the following default theme:

<ThemeRender theme={drawerTheme} />

Learn more about how to customize in the [Theme documentation](/docs/theme/getting-started).


## API
<PropsTable name="Drawer" />

================
File: src/pages/docs/components/layers/menu.mdx
================
import { Canvas, Meta } from '@storybook/blocks';
import * as MenuStories from '../../../../stories/components/Menu.story.tsx';
import { PropsTable } from '@/components/ui/props-table';
import { ToggleCanvas } from '@/components/ui/toggle-canvas';

<Meta of={MenuStories} />

# Menu
The Menu component offers a collection of actions that users can perform in a list format. The typical usecases are
navigation menues, table row selection menu etc.

## Examples
### Basic example
<ToggleCanvas of={MenuStories.Simple} storybook="components-layers-menu--simple" />
### Nested menu items
<ToggleCanvas of={MenuStories.Nested} storybook="components-layers-menu--nested" />

## API
<PropsTable name="Menu" />

================
File: src/pages/docs/components/layers/notification.mdx
================
import { Canvas, Meta } from '@storybook/blocks';
import * as NotificationsStories from '../../../../stories/components/Notification.story.tsx';
import { notificationTheme } from 'reablocks';
import { PropsTable } from '@/components/ui/props-table';
import { ToggleCanvas } from '@/components/ui/toggle-canvas';
import ThemeRender from '@/components/ui/theme-render';

<Meta of={NotificationsStories} />

# Notification
The Notification component delivers real-time messages or alerts to users, providing important updates, feedback, or information within an application.
Notifications can be automatic or can be triggered based on some actions that the user performed.

## Quick Start
Add the `Notifications` provider at the top of your application so that it does not conflict
with other absolutely positioned DOM elements.

```jsx
import { Notifications } from 'reablocks';

const App = () => {
  return (
    <div className='app-container'>
      <Notifications>
        <Application />
       </Notifications>
    </div>
  );
};
```

Use `useNotification` hook to access notify and clearAllNotifications functions

```jsx
import { useNotification, Button } from 'reablocks';

const Component = () => {
   const { notify, clearAllNotifications } = useNotification();
  return (
    <>
      <Button onClick={() => notify('Some text')}>
        Test
      </Button>
      <Button onClick={() => clearAllNotifications()}>
         Clear
      </Button>
    </>
  );
};
```

You can also pass in options when calling the `notify` function to customize the notification.

```tsx
const options: NotificationOptions = {
  body: "This is the body of the notification",
  timeout: 5000,
}

notify("This is a notification", options)
```

The API for the `notify` function is as follows:

```jsx
type NotificationVariants =
  | 'default'
  | 'success'
  | 'warning'
  | 'error'
  | 'info';

interface NotificationOptions {
  title?: string | React.JSX.Element | React.JSX.Element[];
  body?: string | React.JSX.Element | React.JSX.Element[];
  timeout?: number;
  showClose?: boolean;
  variant?: NotificationVariants;
  className?: string;
  icon?: string | React.JSX.Element | React.JSX.Element[];
  action?: string | React.JSX.Element | React.JSX.Element[];
}
```

## Examples
### Notification for interface essential scenarios
<ToggleCanvas of={NotificationsStories.Variants} storybook="components-layers-notification--variants" />

### Custom styled notitications
<ToggleCanvas of={NotificationsStories.CustomComponent} storybook="components-layers-notification--custom-component" />

### Notifications with title and body
<ToggleCanvas of={NotificationsStories.TitleAndBody} storybook="components-layers-notification--title-and-body" />

## Theme
This component uses the following default theme:

<ThemeRender theme={notificationTheme} />

Learn more about how to customize in the [Theme documentation](/docs/theme/getting-started).

## API
<PropsTable name="Notifications" />

================
File: src/pages/docs/components/layers/popover.mdx
================
import { Canvas, Meta } from '@storybook/blocks';
import * as PopoverStories from '../../../../stories/components/Popover.story.tsx';
import { popoverTheme } from 'reablocks';
import { PropsTable } from '@/components/ui/props-table';
import { ToggleCanvas } from '@/components/ui/toggle-canvas';
import ThemeRender from '@/components/ui/theme-render';

<Meta of={PopoverStories} />

# Popover
An element that pops up from another element over other content; it differs from a
tooltip in that it is usually triggered via click instead of hover and can contain interactive elements.

## Examples
<ToggleCanvas of={PopoverStories.Simple} storybook="components-layers-popover--simple" />

## Theme
This component uses the following default theme:

<ThemeRender theme={popoverTheme} />

Learn more about how to customize in the [Theme documentation](/docs/theme/getting-started).

## API
<PropsTable name="Popover" />

================
File: src/pages/docs/components/layers/tooltip.mdx
================
import { Canvas, Meta } from '@storybook/blocks';
import * as TooltipStories from '../../../../stories/components/Tooltip.story.tsx';
import { tooltipTheme } from 'reablocks';
import { PropsTable } from '@/components/ui/props-table';
import { ToggleCanvas } from '@/components/ui/toggle-canvas';
import ThemeRender from '@/components/ui/theme-render';

<Meta of={TooltipStories} />

# Tooltip
A Tooltip is a small, informative pop-up that provides context, explanations, or additional details when a user hovers over or interacts with specific elements in a user interface.

## Examples
### Basic
<ToggleCanvas of={TooltipStories.Simple} storybook="components-layers-tooltip--simple" />
### Disabled
<ToggleCanvas of={TooltipStories.Disabled} storybook="components-layers-tooltip--disabled" />

## Theme
This component uses the following default theme:

<ThemeRender theme={tooltipTheme} />

Learn more about how to customize in the [Theme documentation](/docs/theme/getting-started).

## API
<PropsTable name="Tooltip" />

================
File: src/pages/docs/components/layout/block.mdx
================
import { Canvas, Meta } from '@storybook/blocks';
import { Cards } from 'nextra/components'
import * as BlockStories from '../../../../stories/components/Block.story.tsx';
import { blockTheme } from 'reablocks';
import { PropsTable } from '@/components/ui/props-table';
import { ToggleCanvas } from '@/components/ui/toggle-canvas';
import ThemeRender from '@/components/ui/theme-render';

<Meta of={BlockStories} />

# Block
Simple block component.

## Examples
<ToggleCanvas of={BlockStories.Label} storybook="components-layout-block--label" />

### Blocks
This component is used in the following Blocks:

<Cards>
  <Cards.Card title="Forgot Password" href="/blocks/authentication/forgot-password" />
  <Cards.Card title="Login" href="/blocks/authentication/login" />
  <Cards.Card title="MFA" href="/blocks/authentication/mfa" />
  <Cards.Card title="Profile" href="/blocks/administration/profile" />
  <Cards.Card title="Register" href="/blocks/authentication/register" />
  <Cards.Card title="Contact" href="/blocks/foundation/contact" />
</Cards>

## Theme
This component uses the following default theme:

<ThemeRender theme={blockTheme} />

Learn more about how to customize in the [Theme documentation](/docs/theme/getting-started).

## API
<PropsTable name="Block" />

================
File: src/pages/docs/components/layout/breadcrumbs.mdx
================
import { Canvas, Meta } from '@storybook/blocks';
import * as BreadcrumbStories from '../../../../stories/components/Breadcrumbs.story.tsx';
import { breadcrumbsTheme } from 'reablocks';
import { PropsTable } from '@/components/ui/props-table';
import { ToggleCanvas } from '@/components/ui/toggle-canvas';
import ThemeRender from '@/components/ui/theme-render';

<Meta of={BreadcrumbStories} />

# Breadcrumbs
A breadcrumbs is a list of links that help visualize a page's location within a
site's hierarchical structure, it allows navigation up to any of the ancestors.

## Examples
<ToggleCanvas of={BreadcrumbStories.Basic} storybook="components-layout-breadcrumbs--basic" />

## Theme
This component uses the following default theme:

<ThemeRender theme={breadcrumbsTheme} />

Learn more about how to customize in the [Theme documentation](/docs/theme/getting-started).

## API
<PropsTable name="Breadcrumbs" />

================
File: src/pages/docs/components/layout/callout.mdx
================
import { Canvas, Meta } from '@storybook/blocks';
import { Cards } from 'nextra/components'
import * as CalloutStories from '../../../../stories/components/Callout.story.tsx';
import { calloutTheme } from 'reablocks';
import { PropsTable } from '@/components/ui/props-table';
import { ToggleCanvas } from '@/components/ui/toggle-canvas';
import ThemeRender from '@/components/ui/theme-render';

<Meta of={CalloutStories} />

# Callout
Short message to attract user's attention.

## Examples
<ToggleCanvas of={CalloutStories.Variants} storybook="components-layers-callout--variants" />


## Theme
This component uses the following default theme:

<ThemeRender theme={calloutTheme} />

Learn more about how to customize in the [Theme documentation](/docs/theme/getting-started).

## API
<PropsTable name="Callout" />

<Cards>
  <Cards.Card title="Billing" href="/blocks/administration/billing" />
  <Cards.Card title="Profile" href="/blocks/administration/profile" />
</Cards>

================
File: src/pages/docs/components/layout/card.mdx
================
import { Canvas, Meta } from '@storybook/blocks';
import { Cards } from 'nextra/components'
import * as CardStories from '../../../../stories/components/Card.story.tsx';
import { cardTheme } from 'reablocks';
import { PropsTable } from '@/components/ui/props-table';
import { ToggleCanvas } from '@/components/ui/toggle-canvas';
import ThemeRender from '@/components/ui/theme-render';

<Meta of={CardStories} />

# Card
Cards are a fundamental building block for compositions, such as forms, or sections.

## Examples
<ToggleCanvas of={CardStories.Basic} storybook="components-layout-card--basic" />

### Blocks
This component is used in the following Blocks:

<Cards>
  <Cards.Card title="Billing" href="/blocks/administration/billing" />
  <Cards.Card title="Profile" href="/blocks/administration/profile" />
</Cards>

## Theme
This component uses the following default theme:

<ThemeRender theme={cardTheme} />

Learn more about how to customize in the [Theme documentation](/docs/theme/getting-started).

## API
<PropsTable name="Card" />

================
File: src/pages/docs/components/layout/collapse.mdx
================
import { Canvas, Meta } from '@storybook/blocks';
import * as CollapseStories from '../../../../stories/components/Collapse.story.tsx';
import { PropsTable } from '@/components/ui/props-table';
import { ToggleCanvas } from '@/components/ui/toggle-canvas';

<Meta of={CollapseStories} />

# Collapse
Simple expand / collapse component with animations via framer-motion.

## Examples
<ToggleCanvas of={CollapseStories.Simple} storybook="components-layout-collapse--simple" />

## API
<PropsTable name="Collapse" />

================
File: src/pages/docs/components/layout/divider.mdx
================
import { Canvas, Meta } from '@storybook/blocks';
import { Cards } from 'nextra/components'
import * as DividerStories from '../../../../stories/components/Divider.story.tsx';
import { dividerTheme } from 'reablocks';
import { PropsTable } from '@/components/ui/props-table';
import { ToggleCanvas } from '@/components/ui/toggle-canvas';
import ThemeRender from '@/components/ui/theme-render';

<Meta of={DividerStories} />

# Divider
A simple divider component that supports horizontal and vertical.

## Examples
<ToggleCanvas of={DividerStories.Horizontal} storybook="components-layout-divider--horizontal" />

### Blocks
This component is used in the following Blocks:

<Cards>
  <Cards.Card title="Forgot Password" href="/blocks/authentication/forgot-password" />
  <Cards.Card title="Login" href="/blocks/authentication/login" />
  <Cards.Card title="MFA" href="/blocks/authentication/mfa" />
  <Cards.Card title="Register" href="/blocks/authentication/register" />
  <Cards.Card title="Empty State" href="/blocks/foundation/empty-state" />
  <Cards.Card title="Billing" href="/blocks/administration/billing" />
  <Cards.Card title="Pricing" href="/blocks/administration/pricing" />
  <Cards.Card title="Team" href="/blocks/administration/team" />
</Cards>

## Theme
This component uses the following default theme:

<ThemeRender theme={dividerTheme} />

Learn more about how to customize in the [Theme documentation](/docs/theme/getting-started).

## API
<PropsTable name="Divider" />

================
File: src/pages/docs/components/layout/json-tree.mdx
================
import { Canvas, Meta } from '@storybook/blocks';
import * as TreeStories from '../../../../stories/components/JsonTree.story.tsx';
import { jsonTreeTheme } from 'reablocks';
import { PropsTable } from '@/components/ui/props-table';
import { ToggleCanvas } from '@/components/ui/toggle-canvas';
import ThemeRender from '@/components/ui/theme-render';

<Meta of={TreeStories} />

# Json Tree
Tree component designed for showing JSON data.

## Examples
<ToggleCanvas of={TreeStories.Simple} storybook="components-layout-tree-json--simple" />

## Theme
This component uses the following default theme:

<ThemeRender theme={jsonTreeTheme} />

Learn more about how to customize in the [Theme documentation](/docs/theme/getting-started).

## API
### Tree
<PropsTable name="JsonTree" />

### TreeNode
<PropsTable name="JsonTreeNode" />

================
File: src/pages/docs/components/layout/list.mdx
================
import { Canvas, Meta } from '@storybook/blocks';
import { Cards } from 'nextra/components'
import * as ListItemStories from '../../../../stories/components/List.story.tsx';
import { listTheme } from 'reablocks';
import { PropsTable } from '@/components/ui/props-table';
import { ToggleCanvas } from '@/components/ui/toggle-canvas';
import ThemeRender from '@/components/ui/theme-render';

<Meta of={ListItemStories} />

# List
Simple list and list item component.

## Examples
<ToggleCanvas of={ListItemStories.Simple} storybook="components-layout-list--simple" />

### Blocks
This component is used in the following Blocks:

<Cards>
  <Cards.Card title="Pricing" href="/blocks/administration/pricing" />
</Cards>

## Theme
This component uses the following default theme:

<ThemeRender theme={listTheme} />

Learn more about how to customize in the [Theme documentation](/docs/theme/getting-started).

## API
<PropsTable name="ListItem" />

================
File: src/pages/docs/components/layout/motion.mdx
================
import { Canvas, Meta } from '@storybook/blocks';
import { Cards } from 'nextra/components'
import * as MotionStories from '../../../../stories/components/Motion.story.tsx';
import { PropsTable } from '@/components/ui/props-table';
import { ToggleCanvas } from '@/components/ui/toggle-canvas';

<Meta of={MotionStories} />

# Motion
Basic motion helpers for animating components using framer-motion.

## Examples
<ToggleCanvas of={MotionStories.Simple} storybook="components-layout-motion--simple" />

### Blocks
This component is used in the following Blocks:

<Cards>
  <Cards.Card title="Not Found" href="/blocks/foundation/not-found" />
  <Cards.Card title="Pricing" href="/blocks/administration/pricing" />
  <Cards.Card title="Profile" href="/blocks/administration/profile" />
</Cards>

## API

### MotionGroup
<PropsTable name="MotionGroup" />

### MotionItem
<PropsTable name="MotionItem" />

================
File: src/pages/docs/components/layout/stack.mdx
================
import { Canvas, Meta } from '@storybook/blocks';
import { Cards } from 'nextra/components'
import * as StackStories from '../../../../stories/components/Stack.story.tsx';
import { stackTheme } from 'reablocks';
import { PropsTable } from '@/components/ui/props-table';
import { ToggleCanvas } from '@/components/ui/toggle-canvas';
import ThemeRender from '@/components/ui/theme-render';

<Meta of={StackStories} />

# Stack
Component that sets component spacing. It can be used to add
space between components such as a menu.

## Examples
<ToggleCanvas of={StackStories.Simple} storybook="components-layout-stack--simple" />

### Blocks
This component is used in the following Blocks:

<Cards>
  <Cards.Card title="Forgot Password" href="/blocks/authentication/forgot-password" />
  <Cards.Card title="Login" href="/blocks/authentication/login" />
  <Cards.Card title="MFA" href="/blocks/authentication/mfa" />
  <Cards.Card title="Register" href="/blocks/authentication/register" />
  <Cards.Card title="Not Found" href="/blocks/foundation/not-found" />
  <Cards.Card title="Contact" href="/blocks/foundation/contact" />
  <Cards.Card title="Billing" href="/blocks/administration/billing" />
  <Cards.Card title="Pricing" href="/blocks/administration/pricing" />
  <Cards.Card title="Team" href="/blocks/administration/team" />
  <Cards.Card title="Profile" href="/blocks/administration/profile" />
  <Cards.Card title="Timeline" href="/blocks/foundation/timeline" />
</Cards>

## Theme
This component uses the following default theme:

<ThemeRender theme={stackTheme} />

Learn more about how to customize in the [Theme documentation](/docs/theme/getting-started).

## API
<PropsTable name="Stack" />

================
File: src/pages/docs/components/layout/stepper.mdx
================
import { Canvas, Meta } from '@storybook/blocks';
import { Cards } from 'nextra/components'
import * as StepperStories from '../../../../stories/components/Stepper.story.tsx';
import { stepperTheme } from 'reablocks';
import { PropsTable } from '@/components/ui/props-table';
import { ToggleCanvas } from '@/components/ui/toggle-canvas';
import ThemeRender from '@/components/ui/theme-render';

<Meta of={StepperStories} />

# Stepper
A representation of a user's progress through a series of discrete steps.

## Examples
### Markers
<ToggleCanvas of={StepperStories.Markers} storybook="components-layout-stepper--markers" />

### Numbered
<ToggleCanvas of={StepperStories.Numbered} storybook="components-layout-stepper--numbered" />

### Blocks
This component is used in the following Blocks:

<Cards>
  <Cards.Card title="🕦 Timeline" href="/blocks/foundation/timeline" />
  <Cards.Card title="👤 Profile" href="/blocks/administration/profile" />
</Cards>

## Theme
This component uses the following default theme:

<ThemeRender theme={stepperTheme} />

Learn more about how to customize in the [Theme documentation](/docs/theme/getting-started).

## API
### Stepper
<PropsTable name="Stepper" />

### Step
<PropsTable name="Step" />

================
File: src/pages/docs/components/layout/tabs.mdx
================
import { Canvas, Meta } from '@storybook/blocks';
import { Cards } from 'nextra/components'
import * as TabsStories from '../../../../stories/components/Tabs.story.tsx';
import { tabsTheme } from 'reablocks';
import { PropsTable } from '@/components/ui/props-table';
import { ToggleCanvas } from '@/components/ui/toggle-canvas';
import ThemeRender from '@/components/ui/theme-render';

<Meta of={TabsStories} />

# Tabs
The tabs component is a simple way to organize content into different sections.

## Examples
<ToggleCanvas of={TabsStories.Simple} storybook="components-layout-tabs--simple" />

### Blocks
This component is used in the following Blocks:

<Cards>
  <Cards.Card title="Billing" href="/blocks/administration/billing" />
  <Cards.Card title="Profile" href="/blocks/administration/profile" />
  <Cards.Card title="Team" href="/blocks/administration/team" />
</Cards>

## Theme
This component uses the following default theme:

<ThemeRender theme={tabsTheme} />

Learn more about how to customize in the [Theme documentation](/docs/theme/getting-started).

## API

### Tabs
<PropsTable name="Tabs" />

### TabList
<PropsTable name="TabList" />

### Tab
<PropsTable name="Tab" />

### TabPanel
<PropsTable name="TabPanel" />

================
File: src/pages/docs/components/layout/tree.mdx
================
import { Canvas, Meta } from '@storybook/blocks';
import * as TreeStories from '../../../../stories/components/Tree.story.tsx';
import { treeTheme } from 'reablocks';
import { PropsTable } from '@/components/ui/props-table';
import { ToggleCanvas } from '@/components/ui/toggle-canvas';
import ThemeRender from '@/components/ui/theme-render';

<Meta of={TreeStories} />

# Tree
Simple tree component for showing hierarchical data.

## Examples
<ToggleCanvas of={TreeStories.Simple} storybook="components-layout-tree--simple" />

## Theme
This component uses the following default theme:

<ThemeRender theme={treeTheme} />

Learn more about how to customize in the [Theme documentation](/docs/theme/getting-started).

## API
### Tree
<PropsTable name="Tree" />

### TreeNode
<PropsTable name="TreeNode" />

================
File: src/pages/docs/components/layout/vertical-spacer.mdx
================
import { Canvas, Meta } from '@storybook/blocks';
import * as VerticalSpacerStories from '../../../../stories/components/VerticalSpacer.story.tsx';
import { verticalSpacerTheme } from 'reablocks';
import { PropsTable } from '@/components/ui/props-table';
import { ToggleCanvas } from '@/components/ui/toggle-canvas';
import ThemeRender from '@/components/ui/theme-render';

<Meta of={VerticalSpacerStories} />

# Vertical Spacer
Simple component to add vertical spacing between elements.

## Examples
<ToggleCanvas of={VerticalSpacerStories.Simple} storybook="components-layout-vertical-spacer--simple" />

## Theme
This component uses the following default theme:

<ThemeRender theme={verticalSpacerTheme} />

Learn more about how to customize in the [Theme documentation](/docs/theme/getting-started).

## API
<PropsTable name="VerticalSpacer" />

================
File: src/pages/docs/components/typography/typography.mdx
================
import { Canvas, Meta } from '@storybook/blocks';
import * as PageTitleStories from '../../../../stories/components/PageTitle.story.tsx';
import * as PrimaryHeadingStories from '../../../../stories/components/PrimaryHeading.story.tsx';
import * as SecondaryHeadingStories from '../../../../stories/components/SecondaryHeading.story.tsx';
import * as TextStories from '../../../../stories/components/Text.story.tsx';
import * as SubStories from '../../../../stories/components/Sub.story.tsx';
import { typographyTheme } from 'reablocks';
import { PropsTable } from '@/components/ui/props-table';
import { ToggleCanvas } from '@/components/ui/toggle-canvas';
import ThemeRender from '@/components/ui/theme-render';

<Meta of={PageTitleStories} />
<Meta of={PrimaryHeadingStories} />
<Meta of={SecondaryHeadingStories} />
<Meta of={TextStories} />
<Meta of={SubStories} />

# Typography
Component for styling text and headings. It contains a set
of components for different heading sizes and text styles.

- `PageTitle` - The page title component is used for the main title of a page.
- `PrimaryHeading` - The primary heading component is used for the main heading of a section.
- `SecondaryHeading` - The secondary heading component is used for the secondary heading of a section.
- `Sub` - The sub component is used for a sub heading of a section.
- `Text` - The text component is used for normal text.

## Examples

### PageTitle
<ToggleCanvas of={PageTitleStories.Simple} storybook="components-typography-pagetitle--simple" />

### PrimaryHeading
<ToggleCanvas of={PrimaryHeadingStories.Simple} storybook="components-typography-primaryheading--simple" />

### SecondaryHeading
<ToggleCanvas of={SecondaryHeadingStories.Simple} storybook="components-typography-secondaryheading--simple" />

### Text
<ToggleCanvas of={TextStories.Simple} storybook="components-typography-text--simple" />

### Sub
<ToggleCanvas of={SubStories.Simple} storybook="components-typography-sub--simple" />

## Theme
This component uses the following default theme:

<ThemeRender theme={typographyTheme} />

Learn more about how to customize in the [Theme documentation](/docs/theme/getting-started).

## API
### PageTitle
<PropsTable name="PageTitle" />

### PrimaryHeading
<PropsTable name="PrimaryHeading" />

### SecondaryHeading
<PropsTable name="SecondaryHeading" />

### Sub
<PropsTable name="Sub" />

### Text
<PropsTable name="Text" />

================
File: src/pages/docs/getting-started/migration.mdx
================
import { Steps } from 'nextra/components'
import { Tabs, Tab, TabList, TabPanel } from 'reablocks'

## Migrating from 8.x to 9.x
In 9.x, we've upgraded to Tailwind CSS v4.x. This upgrade includes several breaking changes.

<Steps>
### Move all theme tokens from `tailwind.config.js` to `index.css`

Please follow the guide depending on the number of themes you have in your project.

<Tabs className="mt-4">
  <TabList>
    <Tab>Single Theme</Tab>
    <Tab>Multiple Themes</Tab>
  </TabList>
  <TabPanel>
  Migrate from this `tailwind.config.js`:
    ```tsx
    const config: Config = {
      theme: {
        extend: {
          colors: {
            primary: {
              DEFAULT: colorPalette.blue[500],
              active: colorPalette.blue[500],
              hover: colorPalette.blue[600],
              inactive: colorPalette.gray[500]
            },

            ... other tokens
          }
        }
      }
    }
    ```

  Migrate to this `index.css`:
    ```css
    @theme {
      --color-primary: var(--color-blue-500);
      --color-primary-active: var(--color-blue-500);
      --color-primary-hover: var(--color-blue-400);
      --color-primary-inactive: var(--color-blue-200);

      ... other tokens
    }
    ```
  </TabPanel>
  <TabPanel>
    Migrate from this `tailwind.config.js`:
    ```tsx
    import { createThemes } from 'tw-colors';

    const config: Config = {
      plugins: [
        createThemes({
          dark: {
            primary: {
              DEFAULT: colorPalette.blue[500],
              active: colorPalette.blue[500],
              hover: colorPalette.blue[600],
              inactive: colorPalette.gray[500]
            },
          },
          light: {
            primary: {
              DEFAULT: colorPalette.red[500],
              active: colorPalette.red[500],
              hover: colorPalette.red[400],
              inactive: colorPalette.gray[200]
            },
          }
        })
      ]
    }
    ```

    Migrate to this `index.css`:
    ```css
    :root,
    :host {
      --reablocks-theme: dark;

      /* Primary colors for default (dark) theme */
      --primary: var(--color-blue-500);
      --primary-active: var(--color-blue-500);
      --primary-hover: var(--color-blue-400);
      --primary-inactive: var(--color-blue-200);

      &.theme-light,
      &[data-theme='light'] {
        --reablocks-theme: light;

        /* Primary colors for light theme */
        --primary: var(--color-red-500);
        --primary-active: var(--color-red-500);
        --primary-hover: var(--color-red-400);
        --primary-inactive: var(--color-gray-200);
      }
    }

    @theme inline {
      --color-primary: var(--primary);
      --color-primary-active: var(--primary-active);
      --color-primary-hover: var(--primary-hover);
      --color-primary-inactive: var(--primary-inactive);
    }
    ```
  </TabPanel>
</Tabs>

### Migrate Tailwind CSS plugins to `index.css`

There is a need to support custom variants used in the previous version via plugins.
If you are using some custom Tailwind CSS plugins, you need to add custom variants to `index.css` to cover the plugins functionality.
```css
/* Custom variants */
@custom-variant dark (&:where(.theme-dark, .theme-dark *, [data-theme=dark], [data-theme=dark] *));
@custom-variant light (&:where(.theme-light, .theme-light *, [data-theme=light], [data-theme=light] *));
@custom-variant disabled-within (&:has(input:is(:disabled), textarea:is(:disabled), button:is(:disabled)));
```

### Add prefix `theme-` to your theme names in class names.

In the previous version, the theme name was used directly as a class name `dark`, `light`, etc.
In the new version, the theme name is prefixed with `theme-` to correctly parsing theme variables.

Here is sample how to define theme name in html tag
```html
<html class="theme-dark">
  ... content ...
</html>
```
or
```html
<html data-theme="dark">
  ... content ...
</html>
```

### Run command to migrate Tailwind CSS class names in your project
This command will migrate all class names to the new format. To review changes you can move to official [Tailwind CSS upgrade guide](https://tailwindcss.com/docs/upgrade-guide).
```shell
npx @tailwindcss/upgrade
```
### Update postcss config
Please update your `postcss.config.mjs` file to use `tailwindcss` plugin.
```js
export default {
  plugins: {
    '@tailwindcss/postcss': {},
  },
};
```

### Add tailwindcss plugin to Vite config (if you are using Vite)
```js
import { defineConfig } from "vite";
import tailwindcss from '@tailwindcss/vite';

export default defineConfig({
  plugins: [
    tailwindcss(),
  ],
});
```

</Steps>

## Migrating from 7.x to 8.x

In 8.x, we've removed the dependency of text colors to panel or surface elements. As text colors are
not necessarily always tied to panel and surface elements, moving these colors into a generic text
block allows for a more flexible design system.

```tsx
{
  // Previously, the structure for panel and surface
  panel: {
    // Panel backgrounds, such as cards, tables, popovers, dialogs, dropdown menus, etc.
    DEFAULT: colorPalette['black-pearl'],
    content: colorPalette['athens-gray'],
    'secondary-content': colorPalette.gray[600],
    accent: colorPalette['charade']
  },
  surface: {
    // Form component backgrounds, such as text fields, checkboxes, select, etc.
    DEFAULT: colorPalette['charade'],
    content: colorPalette['athens-gray'],
    accent: colorPalette.blue[500],
    disabled: colors.gray[800]
  }

  // New structure with added text block
  panel: {
    // Panel backgrounds, such as cards, tables, popovers, dialogs, dropdown menus, etc.
    DEFAULT: colorPalette['black-pearl'],
    accent: colorPalette['charade']
  },
  surface: {
    // Form component backgrounds, such as text fields, checkboxes, select, etc.
    DEFAULT: colorPalette['charade'],
    accent: colorPalette.blue[500],
  },
  text: {
    primary: colorPalette['athens-gray'],
    secondary: colorPalette.gray[600]
  }
}
```

<Steps>
### Move and consolidate content tokens

We set a primary and secondary text color which can be used throughout the app. In addition, we've
consolidated to 2 main text colors, but our system allows for more colors to be added such as
`tertiary` if needed.

For example, if `panel.content` and `surface.content` colors were different, a third color will need
to be added under `text` and theme files of components that are being used will need to be updated.

_We realize that adding a `text` block will mean Tailwind references will end up with duplicate
`text` prefixes such as `text-text-primary` but we feel that this is necessary for our
designs to clearly differentiate colors being used for text and colors being used for ui elements._

```tsx
{
  panel: {
    // Panel backgrounds, such as cards, tables, popovers, dialogs, dropdown menus, etc.
    DEFAULT: colorPalette['black-pearl'],
-   content: colorPalette['athens-gray'],
-   'secondary-content': colorPalette.gray[600],
    accent: colorPalette['charade']
  },
  surface: {
    // Form component backgrounds, such as text fields, checkboxes, select, etc.
    DEFAULT: colorPalette['charade'],
-   content: colorPalette['athens-gray'],
    accent: colorPalette.blue[500],
    disabled: colors.gray[800]
  },
+ text: {
+   primary: colorPalette['athens-gray'],
+   secondary: colorPalette.gray[600],
+ }
}
```

### Update theme files of components being used

This is ONLY necessary if `panel.content` and `surface.content` tokens are different.

Add a new token to the `text` block (ie, `tertiary`) with the color that `surface.content`
was.

```tsx
{
  text: {
    primary: colorPalette['athens-gray'],
    secondary: colorPalette.gray[600],
+   tertiary: colorPalette['waterloo']
  }
}
```

Update component theme files which previously referenced `surface.content` from `*-surface-content` to
`*-text-secondary`:

- PagerTheme: `base`
- RedactTheme: `base`
- SortTheme: `base`
- ArrowTheme: `base`
- AvatarGroupTheme: `base`
- BadgeTheme:
  - `colors.primary`
  - `colors.secondary`
  - `colors.error`
- ButtonTheme:
  - `base`
  - `colors.default.text`
  - `colors.primary.filled`
  - `colors.secondary.filled`
  - `colors.success.filled`
  - `colors.warning.filled`
  - `colors.error.filled`
- DotsLoaderTheme: `dot`
- CheckboxTheme: `base`
- InputTheme:
  - `base`
  - `adornment.base`
- RangeTheme: `tooltip`
- SelectMenuTheme: `groupItem.title`
- TooltipTheme: `base`
- ListItemTheme:
  - `base`
  - `header`
- StackTheme: `base`
- TreeTheme:
  - `arrow`
  - `node.base`
  - `node.button.icon`

### Remove surface.disabled

We have removed the `surface.disabled` color as it was not being used in any of our component theme
files - only in a story block which has been updated. If there is a reference to this color, leaving
the color in place will continue to work. Otherwise, we recommend removing this color token from the
theme.

```tsx
{
  surface: {
    ...,
-   disabled: colorPalette.gray[800]
  }
}
```

</Steps>

## Migrating from 6.x to 7.x
In 7.x, we've introduced new supporting palettes for things like: panel, surface and backgrounds. This
allows us to define a more consistent and flexible color system for our components.

```tsx
{
  panel: {
    // Panel backgrounds, such as cards, tables, popovers, dialogs, dropdown menus, etc.
    DEFAULT: colorPalette['black-pearl'],
    content: colorPalette['athens-gray'],
    'secondary-content': colorPalette.gray[600],
    accent: colorPalette['charade']
  },
  surface: {
    // Form component backgrounds, such as text fields, checkboxes, select, etc.
    DEFAULT: colorPalette['charade'],
    content: colorPalette['athens-gray'],
    accent: colorPalette.blue[500],
    disabled: colors.gray[800]
  }
}
```

We've also introduced a new color system that allows us to define a more consistent and flexible color system for our components.
The color palettes for Dark and Light themes are now defined using `tw-colors` plugin as a result DarkTheme & LightTheme was merged in theme.
<Steps>
### Update import to use theme from reablocks instead of `darkTheme` and `lightTheme`

```tsx
- import { darkTheme, lightTheme } from 'reablocks';
+ import { theme as defaultTheme } from 'reablocks';

const theme = extendTheme(defaultTheme, themeOverrides);

<ThemeProvider theme={theme}></ThemeProvider>
````

In case when you want to use several themes in your project, you should install `tw-colors` plugin and define your custom themes.

```shell copy
npm i -D tw-colors
```

Example of palettes defined in `tailwind.config.js`:

```tsx
import plugin from 'tailwindcss/plugin';
import { createThemes } from 'tw-colors';

const colorPalette = {
  // Define your color palette here
};

const config: Config = {
  darkMode: 'selector',
  plugins: [
    createThemes({
      light: {
        primary: {
          DEFAULT: colorPalette.blue[500],
          active: colorPalette.blue[500],
          hover: colorPalette.blue[400],
          inactive: colorPalette.gray[500]
        }
        // etc...
      },
      dark: {
        primary: {
          DEFAULT: colorPalette.blue[500],
          active: colorPalette.blue[500],
          hover: colorPalette.blue[600],
          inactive: colorPalette.blue[200]
        }
        // etc...
      }
    })
  ]
};
```

### Update color tokens

```tsx
// Previously tokens structure
colors: {
  primary: colors.blue,
  secondary: colors.gray,
  success: colors.green,
  error: colors.red,
  warning: colors.orange,
  info: colors.sky,
}
// New tokens structure
colors: {
  primary: {
    DEFAULT: colorPalette.blue[500],
    active: colorPalette.blue[500],
    hover: colorPalette.blue[400],
    inactive: colorPalette.gray[500]
  },
  secondary: {
    DEFAULT: colorPalette.gray[300],
    active: colorPalette.gray[300],
    hover: colorPalette.gray[200],
    inactive: colorPalette.gray[800]
  },
  success: {
    DEFAULT: colorPalette.green[500],
    active: colorPalette.green[500],
    hover: colorPalette.green[400]
  },
  error: {
    DEFAULT: colorPalette.red[500],
    active: colorPalette.red[400],
    hover: colorPalette.red[600]
  },
  warning: {
    DEFAULT: colorPalette.orange[500],
    active: colorPalette.orange[500],
    hover: colorPalette.orange[400]
  },
  info: {
    DEFAULT: colorPalette.blue[500],
    active: colorPalette.blue[500],
    hover: colorPalette.blue[400]
  }
}
```

</Steps>

## Migrating from 5.x to 6.x
We're excited to announce that version 6.x of our Storybook library introduces a groundbreaking approach to theming with Tailwind CSS.
This upgrade allows you to leverage the full capabilities of Tailwind CSS, offering a more flexible and powerful way to style your components.
As part of this transition, we're moving away from the previous CSS variables method to embrace a more dynamic and efficient workflow.

### Getting Started with the Migration
To ensure a seamless transition to version 6.x, please follow the steps outlined below.
<Steps>

### Install Tailwind CSS
Begin by installing Tailwind CSS in your project:
Refer to the Tailwind CSS [Getting Started](/docs/getting-started/setup) guide for installation instructions.

### Integrate Tailwind CSS Variables
Next, incorporate Tailwind CSS Variables into your project as a development dependency:
#### **1.** Install the Tailwind CSS Variables package:
```shell copy
  npm install -D @mertasan/tailwindcss-variables
```

#### **2.** Configure the plugin in your `tailwind.config.js`:
Instead of using `require`, import the plugin directly to ensure compatibility with Storybook ThemeBlocks.
```js
import tailwindcssVariables from '@mertasan/tailwindcss-variables';
// ...
module.exports = {
// ...
  plugins: [
    tailwindcssVariables
  ]
}
```

### Migrate Legacy Theme Variables
Adapt your existing theme variables for compatibility with the new system:
#### **1.** Rename your old theme file to `legacyTheme.ts`.

#### **2.** Import legacyTheme in `tailwind.config.js` and define the theme variables:

```js

import defaultTheme from 'tailwindcss/defaultTheme';
import tailwindcssVariables from '@mertasan/tailwindcss-variables';
import { legacyTheme } from './src/Theme/legacyTheme.ts';

/** @type {import('tailwindcss').Config} */
export default {
  content: [
    './src/**/*.{js,jsx,ts,tsx,css}',
    './node_modules/reablocks/**/*.{js,tsx,cjs}'
  ],
  theme: {
    extend: {
      colors: legacyTheme.colors,
      spacing: legacyTheme.spacings,
      fontSize: legacyTheme.typography.sizes,
      fontFamily: {
        'mono': ['"Monaco, monospace"', ...defaultTheme.fontFamily.sans]
      },
      fontWeight: legacyTheme.typography.weights,
    },
    variables: {
      DEFAULT: {
        ...legacyTheme.colors,
        spacing: legacyTheme.spacings,
        'font-size': legacyTheme.typography.sizes,
        'font-weight': legacyTheme.typography.weights,
        'shadow': legacyTheme.shadows,
        'gradient': legacyTheme.gradients,
        border: legacyTheme.borders,
        // Legacy theme components variables
        ...Object.values(legacyTheme.components).reduce((acc, obj) => ({ ...acc, ...obj }), {}),
      }
    }
  },
  plugins: [
    tailwindcssVariables
  ]
}
```
Note: Prefer to use plugin without `require`, because it's will not work in Storybook ThemeBlocks.

***Wrong:***
```js
{
  plugins: [
    require('@mertasan/tailwindcss-variables')
  ]
}
```
***Right:***
```js
import tailwindcssVariables from '@mertasan/tailwindcss-variables';

{
  plugins: [
    tailwindcssVariables
  ]
}
```

#### **3.** Access Tailwind tokens in your code through a `config.ts file`:
```js
import resolveConfig from 'tailwindcss/resolveConfig';
import tailwindConfig from '../path_to_config/tailwind.config.js';

const { theme: TWConfig } = resolveConfig(tailwindConfig);

export default TWConfig;

````
**Note:** If you're using Reablocks Storybook blocks, ensure they are updated to utilize the new theming approach:

```diff
import TWConfig from './config';

- export const Colors = () => <ColorBlocks />;
+ export const Colors = () => <ColorBlocks colors={TWConfig.colors} />;
```

### Establish a New Theme
Define and integrate your new theme, optionally extending it with legacy variables:

#### **1.** Create a `theme.ts` file and outline your new theme structure:
**Note:** Here is used `legacyThemeVars` to extend the new theme with the old theme variables, also available `darkTheme` and `lightTheme` themes (these themes doesn't support legacy css variable).

```js
import { extendTheme, legacyThemeVars, PartialReablocksTheme } from 'reablocks';

const theme: PartialReablocksTheme = {
  // Override the default theme here, Example:
}

export const projectNameTheme = extendTheme(legacyThemeVars, theme);
```

#### **2.** Update theme in your `ThemeProvider`:

```diff
import { projectNameTheme } from './path_to_theme/theme.ts';

- <ThemeProvider theme={oldTheme}>
+ <ThemeProvider theme={projectNameTheme}>
```

### Update Components to the New Theming Approach
Finally, adapt your components to utilize the new theme, leveraging Tailwind and the extended theme variables:
```js
import { extendTheme, legacyThemeVars, PartialReablocksTheme } from 'reablocks';

const theme: PartialReablocksTheme = {
  input: {
    base: `${legacyThemeVars.components.input.base} text-white`, // use concatenation to extend the default legacyThemeVars theme
    input: `placeholder:font-normal` // full override of the default legacyThemeVars theme styles for input
  }
}

export const projectNameTheme = extendTheme(legacyThemeVars, theme);
```
</Steps>

## Seamless Transition & Support

This guide aims to make your migration to 6.x as straightforward as possible.
By following these steps, you'll be able to take full advantage of the new theming capabilities offered by Tailwind CSS within our Storybook library. If you encounter any issues or have questions, please don't hesitate to reach out to our [Good Code](https://goodcode.us?utm=reablocks) team for support.

================
File: src/pages/docs/getting-started/philosophy.mdx
================
# Philosophy
When you first see this library, one of the first questions you
might ask yourself is why another component library; don't we have enough? It's true,
there are a LOT of component libraries out there such as MUI, AntD, and the list continues.
These libraries are very mature and can help you build a great looking application
without too much work, but they come with a number of drawbacks. Let's dive
into why we created this now.

## Design Style Opinions
Libraries such as MUI look great out of the box, but they are extremely
opinionated about their design philosophy and that's OK. Those design
philosophies can help you build a nice looking application very quickly
without the need for a designer.

The problem is if you want a more customized design than say just changing
some colors, it becomes more of a challenge and the benefits begin to dwindle.
Most all offer customization ability but those customizations like disabling the
ripple of a material button come at a cost:

- Download bloat (ripples/animations are hard)
- Internal breaking changes (once you start customizing internal styles which
almost always happens)
- Increased complexity with overrides

By engineering reablocks to use TailwindCSS it lets you avoid all the nasty overrides and
focus on building the product your team needs.

## CSS-IN-JS
When CSS-IN-JS first came out, it was a game changer. It allowed developers the
ability to write runtime CSS which allowed us to break away from the build time
variables we had in LESS/SASS. The ability to do calculations on sizes, dynamically
change colors for dark themes and provide a nice type-safe API.

CSS has matured so much since then, literally almost everything I listed above and
more can be done with native CSS now. By using the native CSS you also get some
other advantages:

- Better performance
- Standard language for styling no matter the project
- Separation of concerns (styles and code belong in different places)

To this day, almost every React-based component library still uses CSS-IN-JS.
There are many die-hard CSS-IN-JS fans out there that could debate this all day long,
it's almost like debating React vs Angular vs Vue though.

Reablocks is designed to use Tailwind CSS for its styling solution. Tailwind
is a utility-first CSS framework that provides a standard way to style components
and is very easy to learn. It's also very easy to customize and has a great
community behind it. We believe this is the best solution for styling components.

## Documentation
Almost all of the libraries I mentioned have great documentation and examples.
The challenge begins once you start customizing the components. Some of them let
you change the colors inline but if you start adding custom CSS styles and such
all that goes out the window. Outside of that, maintaining legacy documentation
for open-source developers is difficult at each version point.

Often times developers will take the examples from the libraries' website and
build out Storybook stories for them so you can have the examples customized to your usage.

Reablocks' documentation is all built inside Storybook. By doing this, all the documentation is in an
easy to consume and standard format that any consumer can import into
their Storybook. We've even built Storybook story helpers and specific
documentation on how to set it up in your application.

Reablocks is the first component library to take a Storybook-first approach.
This is a core principle of ours so we are dedicated to making this as smooth as possible.

## Agnostic Framework Pitfalls
A recent trend in the UI component libraries is to make vanilla JavaScript
components and then create wrappers for them. As an open-source developer,
I understand the reasoning, however, it comes with sacrifices.

- Developers are not able to take advantage of native capabilities and instead
monkey patch to support the various frameworks. This can result in oddities due
to multiple scripts accessing the DOM not in sync with each other.
- The APIs have to make sacrifices, for example, it becomes more difficult to
design APIs that take advantage of some of the awesome React features like JSX inputs.
- The documentation and examples suffer because it's so much to maintain.
- Download bloat is increased because you have to handle things that React just
does manually resulting in a larger download size.

Reablocks is dedicated to React and we are going to be focusing on it exclusively.

## Animations
Most of the libraries have their own animation frameworks
they use internally (or don't even do animations natively).
Animations are not just important for user experience but can provide
valuable experiences to see how data changes over time.

The challenge begins when you need to synchronize animations between
all the various components. For example, you have a drawer component
and when it opens you want to animate in the child components. Usually
developers handle this by doing `setTimeout`` for the duration the drawer
takes to open which is bad for a few reasons.

It's brittle since the timing is based on the ideal system that can animate at that speed
This assumes the animations are all linear, good animations are
spring-based since they feel more natural

Reablocks (and all the Reaviz projects for that matter) are all built on [framer-motion](https://www.framer.com/docs/).
Framer Motion is amazing, it performs spring (and linear if you want) based animations
that happen at 60 FPS and can synchronize between desperate components.
It's a big bet, but Framer-Motion has been out for a while (previously named
React-Pose and based on Popmotion) and is supported by Framer, so as far as bets
are concerned in technology, it's about as good one as you can make.

## Enterprise-focused
One unique attribute of this library is that we aren't trying to make a
library that is everything to everyone. We are focusing on only on
enterprise web applications and more specifically data-intensive applications.
You won't find any hero banners or similar components, instead components like
displaying large numbers, formatting data sizes, and so on.

## Wrap up
We hope you enjoy our hard work, please share with others and let's
make the web a better place.

================
File: src/pages/docs/getting-started/setup.mdx
================
import { Steps } from 'nextra/components'
import { Callout } from 'nextra/components'
import { Tabs, Tab, TabList, TabPanel } from 'reablocks'

# Setup
This section will guide you through the initial steps required to integrate Tailwind CSS into your project. Tailwind CSS is a utility-first CSS framework that can be customized to fit the design needs of your project. Follow these instructions to ensure a smooth setup.
&nbsp;

## Install Steps

<Tabs className="mt-4">
  <TabList>
    <Tab>Manual</Tab>
  </TabList>
  <TabPanel>
    <Callout type="info" emoji="ℹ️">
      If you already have Tailwind installed, you can skip 2nd and 3rd steps.
    </Callout>

    <Steps>
    ### 1. Install Reablocks

    ```sh copy npm2yarn
    npm install reablocks --save
    ```

    <Callout type="info" emoji="ℹ️">
      If you want to use `Reablocks` **prebuilt** theme, without customizing it, please import `reablocks` styles in your CSS file and skip the 6th step.

      ```css copy
      @import "../node_modules/reablocks/dist/index.css";
      ```
    </Callout>

    ### 2. Installing Tailwind CSS
    Open your terminal, navigate to your project's root directory, and run the following command:
    ```sh copy npm2yarn
    npm install tailwindcss @tailwindcss/cli
    ```

    ### 3. Import Tailwind in your CSS
    Add the @import "tailwindcss"; import to your main CSS file.
    ```bash copy
    @import "tailwindcss";
    ```

    ### 4. Add Reablocks to your CSS as a source to be used by Tailwind
    After installing Tailwind CSS, you need to inject reablocks styles into your project.
    -  Open or create your main CSS file. This file is typically located at `src/index.css` or `src/styles.css`.
    -  Add the reablocks as a source to be used by Tailwind at the top of your CSS file:

    ```css copy
    @source "../node_modules/reablocks";
    ```
    **Result:** The reablocks styles are now available to be used by Tailwind.

     ### 5. Configure Reablocks tokens for Tailwind
    Configure default colors tokens (primary, secondary, success, etc) in your main stylesheet file:

    ```css copy
      /* Color tokens */
      :root,
      :host {
        --reablocks-theme: dark;

        /* Primary colors */
        --primary: var(--color-blue-500);
        --primary-active: var(--color-blue-500);
        --primary-hover: var(--color-blue-400);
        --primary-inactive: var(--color-blue-200);

        /* Secondary colors */
        --secondary: var(--color-charade);
        --secondary-active: var(--color-charade);
        --secondary-hover: var(--color-gray-700);
        --secondary-inactive: var(--color-gray-600);

        /* Success colors */
        --success: var(--color-green-500);
        --success-active: var(--color-green-500);
        --success-hover: var(--color-green-400);
        --success-background: var(--color-green-950);

        /* Error colors */
        --error: var(--color-red-500);
        --error-active: var(--color-red-500);
        --error-hover: var(--color-red-400);
        --error-background: var(--color-red-950);

        /* Warning colors */
        --warning: var(--color-orange-500);
        --warning-active: var(--color-orange-500);
        --warning-hover: var(--color-orange-400);
        --warning-background: var(--color-orange-950);

        /* Info colors */
        --info: var(--color-blue-500);
        --info-active: var(--color-blue-500);
        --info-hover: var(--color-blue-400);
        --info-background: var(--color-blue-950);

        /* Panel colors */
        --panel: var(--color-black-pearl);
        --panel-accent: var(--color-charade);

        /* Surface colors */
        --surface: var(--color-charade);
        --surface-accent: var(--color-blue-500);

        /* Text colors */
        --text-primary: var(--color-athens-gray);
        --text-secondary: var(--color-waterloo);

        /* Custom Backgrounds */
        --bottom-border-glow: radial-gradient(
          circle at center,
          var(--color-anakiwa) 0,
          blue,
          transparent 100%
        );
        --button-gradient: linear-gradient(
          283deg,
          #0808a5 0%,
          rgba(8, 8, 165, 0) 100%
        );
        --button-gradient-hover: linear-gradient(
          283deg,
          #44f 0%,
          rgba(23, 23, 255, 0.1) 100%
        );
        --button-gradient-focus: linear-gradient(
          283deg,
          #0d0dd2 0%,
          rgba(23, 23, 255, 0.1) 100%
        );

        &.theme-light,
        &[data-theme="light"] {
          --reablocks-theme: light;

          /* Primary colors */
          --primary: var(--color-blue-500);
          --primary-active: var(--color-blue-500);
          --primary-hover: var(--color-blue-600);
          --primary-inactive: var(--color-gray-500);

          /* Secondary colors */
          --secondary: var(--color-blue-200);
          --secondary-active: var(--color-blue-200);
          --secondary-hover: var(--color-blue-300);
          --secondary-inactive: var(--color-waterloo);

          /* Success colors */
          --success: var(--color-green-500);
          --success-active: var(--color-green-500);
          --success-hover: var(--color-green-600);
          --success-background: var(--color-green-100);

          /* Error colors */
          --error: var(--color-red-500);
          --error-active: var(--color-red-400);
          --error-hover: var(--color-red-600);
          --error-background: var(--color-red-100);

          /* Warning colors */
          --warning: var(--color-orange-500);
          --warning-active: var(--color-orange-500);
          --warning-hover: var(--color-orange-600);
          --warning-background: var(--color-orange-100);

          /* Info colors */
          --info: var(--color-blue-500);
          --info-active: var(--color-blue-500);
          --info-hover: var(--color-blue-600);
          --info-background: var(--color-blue-100);

          /* Panel colors */
          --panel: var(--color-white);
          --panel-accent: var(--color-mystic);

          /* Surface colors */
          --surface: var(--color-gray-300);
          --surface-accent: var(--color-blue-500);

          /* Text colors */
          --text-primary: var(--color-vulcan);
          --text-secondary: var(--color-gray-700);
        }
      }

      /* Custom variants */
      @custom-variant dark (&:where(.theme-dark, .theme-dark *, [data-theme=dark], [data-theme=dark] *));
      @custom-variant light (&:where(.theme-light, .theme-light *, [data-theme=light], [data-theme=light] *));
      @custom-variant disabled-within (&:has(input:is(:disabled), textarea:is(:disabled), button:is(:disabled)));

      /* Define theme tokens */
      @theme {
        /* Fonts */
        --font-sans: "Inter", ui-sans-serif, system-ui, sans-serif,
          "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
        --font-mono: Fira Code, monospace;

        /* Font sizes */
        --text-xs: 0.625rem; /* 10px */
        --text-xs--line-height: 1rem;
        --text-sm: 0.75rem; /* 12px */
        --text-sm--line-height: 1rem;
        --text-base: 0.875rem; /* 14px */
        --text-base--line-height: 1.25rem;
        --text-lg: 1rem; /* 16px */
        --text-lg--line-height: 1.5rem;

        /* Primary colors */
        --color-primary: var(--primary);
        --color-primary-active: var(--primary-active);
        --color-primary-hover: var(--primary-hover);
        --color-primary-inactive: var(--primary-inactive);

        /* Secondary colors */
        --color-secondary: var(--secondary);
        --color-secondary-active: var(--secondary-active);
        --color-secondary-hover: var(--secondary-hover);
        --color-secondary-inactive: var(--secondary-inactive);

        /* Success colors */
        --color-success: var(--success);
        --color-success-active: var(--success-active);
        --color-success-hover: var(--success-hover);
        --color-success-background: var(--success-background);

        /* Error colors */
        --color-error: var(--error);
        --color-error-active: var(--error-active);
        --color-error-hover: var(--error-hover);
        --color-error-background: var(--error-background);

        /* Warning colors */
        --color-warning: var(--warning);
        --color-warning-active: var(--warning-active);
        --color-warning-hover: var(--warning-hover);
        --color-warning-background: var(--warning-background);

        /* Info colors */
        --color-info: var(--info);
        --color-info-active: var(--info-active);
        --color-info-hover: var(--info-hover);
        --color-info-background: var(--info-background);

        /* Panel colors */
        --color-panel: var(--panel);
        --color-panel-accent: var(--panel-accent);

        /* Surface colors */
        --color-surface: var(--surface);
        --color-surface-accent: var(--surface-accent);

        /* Text colors */
        --color-text-primary: var(--text-primary);
        --color-text-secondary: var(--text-secondary);

        /* Base colors */
        --color-white: #ffffff;
        --color-black: #000000;

        /* Gray scale */
        --color-gray-*: initial;
        --color-gray-100: #f7f7fa;
        --color-gray-200: #e6e6f0;
        --color-gray-300: #c9c9d6;
        --color-gray-400: #77778c;
        --color-gray-500: #5c5c73;
        --color-gray-600: #3d3d4d;
        --color-gray-700: #242433;
        --color-gray-800: #1e1e2e;
        --color-gray-900: #11111f;
        --color-gray-950: #02020f;

        /* Magenta */
        --color-magenta-*: initial;
        --color-magenta-100: #fae5f6;
        --color-magenta-200: #f1bfe9;
        --color-magenta-300: #e480d3;
        --color-magenta-400: #d740be;
        --color-magenta-500: #c900a8;
        --color-magenta-600: #ab018f;
        --color-magenta-700: #8c0276;
        --color-magenta-800: #6e025c;
        --color-magenta-900: #4f0343;
        --color-magenta-950: #31042a;

        /* Pink */
        --color-pink-*: initial;
        --color-pink-100: #fde5f1;
        --color-pink-200: #f9bfdb;
        --color-pink-300: #f480b7;
        --color-pink-400: #ee4094;
        --color-pink-500: #de006b;
        --color-pink-600: #bb015a;
        --color-pink-700: #98014a;
        --color-pink-800: #740239;
        --color-pink-900: #510229;
        --color-pink-950: #2e0318;

        /* Lime */
        --color-lime-*: initial;
        --color-lime-100: #f4fae5;
        --color-lime-200: #e3f3bf;
        --color-lime-300: #c6e880;
        --color-lime-400: #aadc40;
        --color-lime-500: #8ed000;
        --color-lime-600: #78b001;
        --color-lime-700: #628f01;
        --color-lime-800: #4c6f02;
        --color-lime-900: #364e02;
        --color-lime-950: #202e03;

        /* Teal */
        --color-teal-*: initial;
        --color-teal-100: #e5fbf9;
        --color-teal-200: #bff6f0;
        --color-teal-300: #80ede0;
        --color-teal-400: #40e5d1;
        --color-teal-500: #00dcc2;
        --color-teal-600: #00c2ab;
        --color-teal-700: #019a88;
        --color-teal-800: #017365;
        --color-teal-900: #024b42;
        --color-teal-950: #02231f;

        /* Cyan */
        --color-cyan-*: initial;
        --color-cyan-100: #e5f9fe;
        --color-cyan-200: #bff0fb;
        --color-cyan-300: #80e2f8;
        --color-cyan-400: #40d3f4;
        --color-cyan-500: #00c5f0;
        --color-cyan-600: #01a7cb;
        --color-cyan-700: #0289a6;
        --color-cyan-800: #036b82;
        --color-cyan-900: #044d5d;
        --color-cyan-950: #052f38;

        /* Violet */
        --color-violet-*: initial;
        --color-violet-100: #f0e8fd;
        --color-violet-200: #dac5f9;
        --color-violet-300: #b58bf3;
        --color-violet-400: #9152ee;
        --color-violet-500: #6c18e8;
        --color-violet-600: #5b14c5;
        --color-violet-700: #4b10a1;
        --color-violet-800: #3a0d7e;
        --color-violet-900: #2a095b;
        --color-violet-950: #190537;

        /* Purple */
        --color-purple-*: initial;
        --color-purple-100: #f3e5fc;
        --color-purple-200: #e2bff7;
        --color-purple-300: #c580f0;
        --color-purple-400: #a840e8;
        --color-purple-500: #8b00e0;
        --color-purple-600: #7501bc;
        --color-purple-700: #5f0298;
        --color-purple-800: #490274;
        --color-purple-900: #330350;
        --color-purple-950: #1d042d;

        /* Red */
        --color-red-*: initial;
        --color-red-100: #fce5e6;
        --color-red-200: #f7bfc1;
        --color-red-300: #f08083;
        --color-red-400: #e84045;
        --color-red-500: #e00007;
        --color-red-600: #b70006;
        --color-red-700: #8e0005;
        --color-red-800: #660104;
        --color-red-900: #3d0103;
        --color-red-950: #200204;

        /* Orange */
        --color-orange-*: initial;
        --color-orange-100: #fef3e5;
        --color-orange-200: #fde1bf;
        --color-orange-300: #fbc280;
        --color-orange-400: #f8a340;
        --color-orange-500: #f68500;
        --color-orange-600: #cb6e00;
        --color-orange-700: #9f5701;
        --color-orange-800: #743f01;
        --color-orange-900: #482802;
        --color-orange-950: #251602;

        /* Yellow */
        --color-yellow-*: initial;
        --color-yellow-100: #fff9e5;
        --color-yellow-200: #fff1bf;
        --color-yellow-300: #ffe380;
        --color-yellow-400: #ffd440;
        --color-yellow-500: #ffc600;
        --color-yellow-600: #d2a300;
        --color-yellow-700: #a58001;
        --color-yellow-800: #785e01;
        --color-yellow-900: #4b3b02;
        --color-yellow-950: #261f03;

        /* Green */
        --color-green-*: initial;
        --color-green-100: #eef8e9;
        --color-green-200: #d5efc8;
        --color-green-300: #aadf91;
        --color-green-400: #80ce5b;
        --color-green-500: #55be24;
        --color-green-600: #469d1d;
        --color-green-700: #377c16;
        --color-green-800: #275c10;
        --color-green-900: #183b09;
        --color-green-950: #091a02;

        /* Blue */
        --color-blue-*: initial;
        --color-blue-100: #e7efff;
        --color-blue-200: #c3d7ff;
        --color-blue-300: #87aeff;
        --color-blue-400: #4c86ff;
        --color-blue-500: #105eff;
        --color-blue-600: #0d4ed2;
        --color-blue-700: #0a3da6;
        --color-blue-800: #082d79;
        --color-blue-900: #051c4c;
        --color-blue-950: #041028;

        /* Named colors */
        --color-black-pearl: #02020f;
        --color-athens-gray: #f7f7fa;
        --color-mystic: #e6e6f0;
        --color-vulcan: #11111f;
        --color-charade: #242433;
        --color-waterloo: #77778c;
        --color-anakiwa: #93b6ff;
      }
    ```

    ### 6. Initialize Theme Provider
    Wrap your application with the `ThemeProvider` component from `reablocks`.

    ```tsx copy
    import { ThemeProvider, theme } from 'reablocks';

    // NOTE: You can extend 'theme' with your own custom theme tokens.

    export const App = () => (
      <ThemeProvider theme={theme}>
        <YourComponents />
      </ThemeProvider>
    );
    ```

    You can learn more about the `ThemeProvider` [here](/docs/theme/getting-started).

    ### 7. Setup Storybook
    Optionally: If you are using Storybook, you can setup the reablocks in Storybook by adding the
    following code to `.storybook/preview.js`:

    ```javascript copy
    import type { Preview } from "@storybook/react";
    import { ThemeProvider, theme } from "reablocks";

    export const decorators = [
      Story => (
        // NOTE: You can extend 'theme' with your own custom theme tokens.
        <ThemeProvider theme={theme}>
          <Story />
        </ThemeProvider>
      )
    ];

    const preview: Preview = {
      // Your other configurations here too
      decorators: [withProvider],
    };
    ```

    You can learn more about the Storybook setup [here](/docs/getting-started/storybook).

    </Steps>
  </TabPanel>
</Tabs>


## Example Repository
You can use the following [repository](https://github.com/goodcodeus/starter) to get started with Reablocks.

## Developing Locally

If you want to run the project locally, its really easy!

The project uses Storybook for its demos and development environment. To run it locally:

- **Clone the repository.**
First, clone the repository to your local machine using Git:

```bash copy
git clone git@github.com:reaviz/reablocks.git
```
- **Install dependencies.**
Navigate to the project directory and install the necessary dependencies:
```bash copy
npm install
```
- **Start Storybook.**
Once the installation is complete, start the Storybook development server:

```bash copy
npm start
```

**Result:** This command runs Storybook locally and opens it in your default web browser at `http://localhost:9009.` You can now view your components, experiment with their properties, and see changes in real-time.
&nbsp;
### Building for Distribution with Rollup
Our project uses Rollup for bundling and preparing the package for distribution. To build the project, simply run:

```bash copy
npm run build
```
**Result:** This command generates a `dist` folder containing the bundled JavaScript, CSS files, and type definitions, ready for deployment or distribution.

================
File: src/pages/docs/getting-started/storybook.mdx
================
import { Steps } from 'nextra/components'

# Storybook
Reablocks is designed with a Storybook-first philosophy, focusing on enabling seamless integration and development within the Storybook environment.
This guide will walk you through setting up Storybook with Reablocks, including the use of the `ThemeProvider` to ensure your design tokens are consistently applied across all your stories.

<Steps>
### Prerequisites
- Ensure Storybook is already set up in your project.
- Install Reablocks in your project (if you haven't already) using npm.

### Create or Update the `preview.jsx` File
The `preview.jsx` file in your `.storybook` directory allows you to customize how stories are rendered in Storybook.
If you don't have this file yet, you'll need to create it to incorporate the `ThemeProvider`.

- Navigate to Your `.storybook` Folder.
- Create or Edit `preview.jsx`.

### Structuring the `preview.jsx` file in Storybook with Reablocks
When incorporating Reablocks into Storybook, one of the key steps is ensuring your design tokens are applied across all stories.
This is efficiently achieved by using the ThemeProvider as a decorator within your .storybook/preview.jsx file.
Below is an example showcasing how we typically structure this file:

- **Import Required Modules:**
Start by importing the necessary modules, including the `DocsContainer` from Storybook's addon-docs, the `ThemeProvider` from Reablocks, and your theme file.

```jsx
import { DocsContainer } from '@storybook/addon-docs';
import { ThemeProvider } from 'reablocks';
import { theme } from '[INSERT_PATH_TO_YOUR_THEME]';
```

- **Set Up Decorators:**
Decorators are utilized to wrap stories for global style or functionality application. Here, we use the `ThemeProvider` to ensure that your design tokens are applied to every story.

```jsx
export const decorators = [
  Story => (
    <ThemeProvider theme={theme}>
      <Story />
    </ThemeProvider>
  )
];
```

- **Configure Global Parameters:**
Define global parameters to adjust the Storybook environment according to your needs. This configuration includes setting the layout, customizing the documentation container to include the `ThemeProvider`, and hiding the no-controls warning.

```jsx
export const parameters = {
  layout: 'centered',
  docs: {
    container: ({ context, children }) => (
      <DocsContainer context={context}>
        <ThemeProvider theme={theme}>
          {children}
        </ThemeProvider>
      </DocsContainer>
    )
  },
  controls: {
    hideNoControlsWarning: true
  }
};
```

### Complete Example
Putting it all together, your `.storybook/preview.jsx` file will look something like this:

```jsx
import { DocsContainer } from '@storybook/addon-docs';
import { ThemeProvider } from 'reablocks';
import { theme } from '[INSERT_PATH_TO_YOUR_THEME]';

export const decorators = [
  Story => (
    <ThemeProvider theme={theme}>
      <Story />
    </ThemeProvider>
  )
];

export const parameters = {
  layout: 'centered',
  docs: {
    container: ({ context, children }) => (
      <DocsContainer context={context}>
        <ThemeProvider theme={theme}>
          {children}
        </ThemeProvider>
      </DocsContainer>
    )
  },
  controls: {
    hideNoControlsWarning: true
  }
};
```
</Steps>

================
File: src/pages/docs/recipes/animations.mdx
================
# Animations
We recommend using [framer-motion](https://www.framer.com/motion/) for animations.
It's a powerful library that makes it easy to animate elements in React. All of the
animations in this library are built using framer-motion.

================
File: src/pages/docs/recipes/forms.mdx
================
import { Meta } from '@storybook/addon-docs';
import { BasicForm } from '@/components/ui/forms';
import { ThemeProvider, theme } from 'reablocks';

<Meta title="Recipes/Form" />

# Forms
reablocks recommended that you use a form library like [react-hook-form](https://react-hook-form.com/) to handle form state.
This will allow you to easily validate and submit your form. Below is an example
of how to use `react-hook-form` with the Input component.

Here is a basic login form example:

<br />
<ThemeProvider theme={theme}>
  <BasicForm />
</ThemeProvider>
<br />

In order to use the `react-hook-form` library, you need to wrap the `Input` in a
`Controller` component. Here is an example of how we wrapped the `Input` component
in the `BasicForm` example above:

```tsx
import { Input } from 'reablocks';
import { useForm, Controller } from 'react-hook-form';

export const BasicForm = () => {
  const { control, handleSubmit } = useForm();

  return (
    <form onSubmit={handleSubmit(values => console.log('values', values))}>
      <Controller
        name="email"
        control={control}
        render={({ field: { value, onBlur, onChange } }) => (
          <Input
            name="email"
            disabled={isSubmitting}
            placeholder="Enter your email address..."
            value={value}
            type="email"
            onChange={onChange}
            onBlur={onBlur}
          />
        )}
      />
    </Form>
  );
};
```

More examples of how to use the `react-hook-form` library can be found in the [official documentation](https://react-hook-form.com/).

================
File: src/pages/docs/recipes/table.mdx
================
# Table
We recommend using [Tanstack's Table](https://tanstack.com/table/latest)
component for displaying tabular data. Examples coming soon!

================
File: src/pages/docs/recipes/uploads.mdx
================
# File Uploads
For file uploads, we recommend using [uppyjs](https://uppy.io/). Uppy is a sleek, modular file uploader
that supports drag and drop, resumable uploads, and more. Examples coming soon!

================
File: src/pages/docs/theme/getting-started.mdx
================
# Getting Started
Reablocks theming is seamlessly integrated into the Tailwind CSS configuration, allowing for a highly customizable design system.
This approach leverages Tailwind's utility-first CSS to offer you an extensive range of design tokens such as colors, border radii, shadows, and font sizes.
In addition, Reablocks provides a set of pre-defined [Storybook blocks](/docs/theme/theme-block) that can be used to quickly build and customize your UI components in a Storybook environment.

### Integrating Reablocks Theme in Your Application
To get started with Reablocks theming, you first need to incorporate the `ThemeProvider` into the root of your application.
This provider applies the selected theme across all your components, ensuring a consistent look and feel.

- **Basic Theme Example**

```tsx
import { ThemeProvider, theme } from 'reablocks';

export const App = () => (
  <ThemeProvider theme={theme}>
    <YourComponents />
  </ThemeProvider>
);
```
**Result:** In this example, the `darkTheme` from Reablocks is applied to your application.
Simply wrap your component hierarchy with the `ThemeProvider`, and the theme is automatically applied.

### Extending the Reablocks Theme
Reablocks allows you to extend its themes to customize according to your design requirements.
You can modify existing styles or add new ones to fit your application's unique design language.

- **Customizing Theme Example**

```tsx
import { ThemeProvider, theme, extendTheme, PartialReablocksTheme } from 'reablocks';

const customTheme: PartialReablocksTheme = {
  components: {
    button: {
      base: 'bg-lime-600 text-gray-300',
      variants: {
        filled: 'bg-lime-600 hover:bg-lime-700',
        outline: 'bg-transparent border-lime-600 border',
        text: 'bg-transparent border-0'
      },
      sizes: {
        small: 'p-2',
        medium: 'p-3',
        large: 'p-4'
      }
    }
  }
};
```

You can extend the `colors`, `variants`, and `sizes` of applicable components with any custom values. This allows you to create properties that are specific to your app's design system.
```tsx
const customTheme: PartialReablocksTheme = {
  components: {
    button: {
      base: 'bg-lime-600 text-gray-300',
      variants: {
        ...
        destructive: 'bg-red-600 hover:bg-red-700',
      },
      sizes: {
        ...
        xxl: 'p-6',
      }
    }
  }
};
```

By using the `extendTheme` function, you can merge your customizations with the base theme, resulting in a coherent design system that still benefits from Reablocks' foundation.

```tsx
export const App = () => (
  <ThemeProvider theme={extendTheme(theme, customTheme)}>
    <YourComponents />
  </ThemeProvider>
);
```

**Result:** This example demonstrates how to create a `customTheme` that extends the `darkTheme`.


&nbsp;

### Switching themes
Simply switch the class or the data-theme attribute on the html element to change the theme.
```html
<html class='theme-dark'> // or class='theme-light'
  ...
</html>
```

### Defining Reablocks Tokens with TailwindCSS
Reablocks themes can further leverage TailwindCSS's configuration to define custom design tokens.
This allows for an even deeper level of customization, integrating seamlessly with your TailwindCSS setup.

- **Reablocks Tokens for dart/light themes**

```css copy
/* Color tokens */
:root,
:host {
  --reablocks-theme: dark;

  /* Primary colors */
  --primary: var(--color-blue-500);
  --primary-active: var(--color-blue-500);
  --primary-hover: var(--color-blue-400);
  --primary-inactive: var(--color-blue-200);

  /* Secondary colors */
  --secondary: var(--color-charade);
  --secondary-active: var(--color-charade);
  --secondary-hover: var(--color-gray-700);
  --secondary-inactive: var(--color-gray-600);

  /* Success colors */
  --success: var(--color-green-500);
  --success-active: var(--color-green-500);
  --success-hover: var(--color-green-400);
  --success-background: var(--color-green-950);

  /* Error colors */
  --error: var(--color-red-500);
  --error-active: var(--color-red-500);
  --error-hover: var(--color-red-400);
  --error-background: var(--color-red-950);

  /* Warning colors */
  --warning: var(--color-orange-500);
  --warning-active: var(--color-orange-500);
  --warning-hover: var(--color-orange-400);
  --warning-background: var(--color-orange-950);

  /* Info colors */
  --info: var(--color-blue-500);
  --info-active: var(--color-blue-500);
  --info-hover: var(--color-blue-400);
  --info-background: var(--color-blue-950);

  /* Panel colors */
  --panel: var(--color-black-pearl);
  --panel-accent: var(--color-charade);

  /* Surface colors */
  --surface: var(--color-charade);
  --surface-accent: var(--color-blue-500);

  /* Text colors */
  --text-primary: var(--color-athens-gray);
  --text-secondary: var(--color-waterloo);

  /* Custom Backgrounds */
  --bottom-border-glow: radial-gradient(
    circle at center,
    var(--color-anakiwa) 0,
    blue,
    transparent 100%
  );
  --button-gradient: linear-gradient(
    283deg,
    #0808a5 0%,
    rgba(8, 8, 165, 0) 100%
  );
  --button-gradient-hover: linear-gradient(
    283deg,
    #44f 0%,
    rgba(23, 23, 255, 0.1) 100%
  );
  --button-gradient-focus: linear-gradient(
    283deg,
    #0d0dd2 0%,
    rgba(23, 23, 255, 0.1) 100%
  );

  &.theme-light,
  &[data-theme="light"] {
    --reablocks-theme: light;

    /* Primary colors */
    --primary: var(--color-blue-500);
    --primary-active: var(--color-blue-500);
    --primary-hover: var(--color-blue-600);
    --primary-inactive: var(--color-gray-500);

    /* Secondary colors */
    --secondary: var(--color-blue-200);
    --secondary-active: var(--color-blue-200);
    --secondary-hover: var(--color-blue-300);
    --secondary-inactive: var(--color-waterloo);

    /* Success colors */
    --success: var(--color-green-500);
    --success-active: var(--color-green-500);
    --success-hover: var(--color-green-600);
    --success-background: var(--color-green-100);

    /* Error colors */
    --error: var(--color-red-500);
    --error-active: var(--color-red-400);
    --error-hover: var(--color-red-600);
    --error-background: var(--color-red-100);

    /* Warning colors */
    --warning: var(--color-orange-500);
    --warning-active: var(--color-orange-500);
    --warning-hover: var(--color-orange-600);
    --warning-background: var(--color-orange-100);

    /* Info colors */
    --info: var(--color-blue-500);
    --info-active: var(--color-blue-500);
    --info-hover: var(--color-blue-600);
    --info-background: var(--color-blue-100);

    /* Panel colors */
    --panel: var(--color-white);
    --panel-accent: var(--color-mystic);

    /* Surface colors */
    --surface: var(--color-gray-300);
    --surface-accent: var(--color-blue-500);

    /* Text colors */
    --text-primary: var(--color-vulcan);
    --text-secondary: var(--color-gray-700);
  }
}
```
These tokens are used to define the colors for the dark and light themes.


- **TailwindCSS Configuration Example**

```css copy
/* Custom variants */
@custom-variant dark (&:where(.theme-dark, .theme-dark *, [data-theme=dark], [data-theme=dark] *));
@custom-variant light (&:where(.theme-light, .theme-light *, [data-theme=light], [data-theme=light] *));
@custom-variant disabled-within (&:has(input:is(:disabled), textarea:is(:disabled), button:is(:disabled)));

/* Define theme tokens */
@theme {
  /* Fonts */
  --font-sans: "Inter", ui-sans-serif, system-ui, sans-serif,
    "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
  --font-mono: Fira Code, monospace;

  /* Font sizes */
  --text-xs: 0.625rem; /* 10px */
  --text-xs--line-height: 1rem;
  --text-sm: 0.75rem; /* 12px */
  --text-sm--line-height: 1rem;
  --text-base: 0.875rem; /* 14px */
  --text-base--line-height: 1.25rem;
  --text-lg: 1rem; /* 16px */
  --text-lg--line-height: 1.5rem;

  /* Primary colors */
  --color-primary: var(--primary);
  --color-primary-active: var(--primary-active);
  --color-primary-hover: var(--primary-hover);
  --color-primary-inactive: var(--primary-inactive);

  /* Secondary colors */
  --color-secondary: var(--secondary);
  --color-secondary-active: var(--secondary-active);
  --color-secondary-hover: var(--secondary-hover);
  --color-secondary-inactive: var(--secondary-inactive);

  /* Success colors */
  --color-success: var(--success);
  --color-success-active: var(--success-active);
  --color-success-hover: var(--success-hover);
  --color-success-background: var(--success-background);

  /* Error colors */
  --color-error: var(--error);
  --color-error-active: var(--error-active);
  --color-error-hover: var(--error-hover);
  --color-error-background: var(--error-background);

  /* Warning colors */
  --color-warning: var(--warning);
  --color-warning-active: var(--warning-active);
  --color-warning-hover: var(--warning-hover);
  --color-warning-background: var(--warning-background);

  /* Info colors */
  --color-info: var(--info);
  --color-info-active: var(--info-active);
  --color-info-hover: var(--info-hover);
  --color-info-background: var(--info-background);

  /* Panel colors */
  --color-panel: var(--panel);
  --color-panel-accent: var(--panel-accent);

  /* Surface colors */
  --color-surface: var(--surface);
  --color-surface-accent: var(--surface-accent);

  /* Text colors */
  --color-text-primary: var(--text-primary);
  --color-text-secondary: var(--text-secondary);

  /* Base colors */
  --color-white: #ffffff;
  --color-black: #000000;

  /* Gray scale */
  --color-gray-*: initial;
  --color-gray-100: #f7f7fa;
  --color-gray-200: #e6e6f0;
  --color-gray-300: #c9c9d6;
  --color-gray-400: #77778c;
  --color-gray-500: #5c5c73;
  --color-gray-600: #3d3d4d;
  --color-gray-700: #242433;
  --color-gray-800: #1e1e2e;
  --color-gray-900: #11111f;
  --color-gray-950: #02020f;

  /* Magenta */
  --color-magenta-*: initial;
  --color-magenta-100: #fae5f6;
  --color-magenta-200: #f1bfe9;
  --color-magenta-300: #e480d3;
  --color-magenta-400: #d740be;
  --color-magenta-500: #c900a8;
  --color-magenta-600: #ab018f;
  --color-magenta-700: #8c0276;
  --color-magenta-800: #6e025c;
  --color-magenta-900: #4f0343;
  --color-magenta-950: #31042a;

  /* Pink */
  --color-pink-*: initial;
  --color-pink-100: #fde5f1;
  --color-pink-200: #f9bfdb;
  --color-pink-300: #f480b7;
  --color-pink-400: #ee4094;
  --color-pink-500: #de006b;
  --color-pink-600: #bb015a;
  --color-pink-700: #98014a;
  --color-pink-800: #740239;
  --color-pink-900: #510229;
  --color-pink-950: #2e0318;

  /* Lime */
  --color-lime-*: initial;
  --color-lime-100: #f4fae5;
  --color-lime-200: #e3f3bf;
  --color-lime-300: #c6e880;
  --color-lime-400: #aadc40;
  --color-lime-500: #8ed000;
  --color-lime-600: #78b001;
  --color-lime-700: #628f01;
  --color-lime-800: #4c6f02;
  --color-lime-900: #364e02;
  --color-lime-950: #202e03;

  /* Teal */
  --color-teal-*: initial;
  --color-teal-100: #e5fbf9;
  --color-teal-200: #bff6f0;
  --color-teal-300: #80ede0;
  --color-teal-400: #40e5d1;
  --color-teal-500: #00dcc2;
  --color-teal-600: #00c2ab;
  --color-teal-700: #019a88;
  --color-teal-800: #017365;
  --color-teal-900: #024b42;
  --color-teal-950: #02231f;

  /* Cyan */
  --color-cyan-*: initial;
  --color-cyan-100: #e5f9fe;
  --color-cyan-200: #bff0fb;
  --color-cyan-300: #80e2f8;
  --color-cyan-400: #40d3f4;
  --color-cyan-500: #00c5f0;
  --color-cyan-600: #01a7cb;
  --color-cyan-700: #0289a6;
  --color-cyan-800: #036b82;
  --color-cyan-900: #044d5d;
  --color-cyan-950: #052f38;

  /* Violet */
  --color-violet-*: initial;
  --color-violet-100: #f0e8fd;
  --color-violet-200: #dac5f9;
  --color-violet-300: #b58bf3;
  --color-violet-400: #9152ee;
  --color-violet-500: #6c18e8;
  --color-violet-600: #5b14c5;
  --color-violet-700: #4b10a1;
  --color-violet-800: #3a0d7e;
  --color-violet-900: #2a095b;
  --color-violet-950: #190537;

  /* Purple */
  --color-purple-*: initial;
  --color-purple-100: #f3e5fc;
  --color-purple-200: #e2bff7;
  --color-purple-300: #c580f0;
  --color-purple-400: #a840e8;
  --color-purple-500: #8b00e0;
  --color-purple-600: #7501bc;
  --color-purple-700: #5f0298;
  --color-purple-800: #490274;
  --color-purple-900: #330350;
  --color-purple-950: #1d042d;

  /* Red */
  --color-red-*: initial;
  --color-red-100: #fce5e6;
  --color-red-200: #f7bfc1;
  --color-red-300: #f08083;
  --color-red-400: #e84045;
  --color-red-500: #e00007;
  --color-red-600: #b70006;
  --color-red-700: #8e0005;
  --color-red-800: #660104;
  --color-red-900: #3d0103;
  --color-red-950: #200204;

  /* Orange */
  --color-orange-*: initial;
  --color-orange-100: #fef3e5;
  --color-orange-200: #fde1bf;
  --color-orange-300: #fbc280;
  --color-orange-400: #f8a340;
  --color-orange-500: #f68500;
  --color-orange-600: #cb6e00;
  --color-orange-700: #9f5701;
  --color-orange-800: #743f01;
  --color-orange-900: #482802;
  --color-orange-950: #251602;

  /* Yellow */
  --color-yellow-*: initial;
  --color-yellow-100: #fff9e5;
  --color-yellow-200: #fff1bf;
  --color-yellow-300: #ffe380;
  --color-yellow-400: #ffd440;
  --color-yellow-500: #ffc600;
  --color-yellow-600: #d2a300;
  --color-yellow-700: #a58001;
  --color-yellow-800: #785e01;
  --color-yellow-900: #4b3b02;
  --color-yellow-950: #261f03;

  /* Green */
  --color-green-*: initial;
  --color-green-100: #eef8e9;
  --color-green-200: #d5efc8;
  --color-green-300: #aadf91;
  --color-green-400: #80ce5b;
  --color-green-500: #55be24;
  --color-green-600: #469d1d;
  --color-green-700: #377c16;
  --color-green-800: #275c10;
  --color-green-900: #183b09;
  --color-green-950: #091a02;

  /* Blue */
  --color-blue-*: initial;
  --color-blue-100: #e7efff;
  --color-blue-200: #c3d7ff;
  --color-blue-300: #87aeff;
  --color-blue-400: #4c86ff;
  --color-blue-500: #105eff;
  --color-blue-600: #0d4ed2;
  --color-blue-700: #0a3da6;
  --color-blue-800: #082d79;
  --color-blue-900: #051c4c;
  --color-blue-950: #041028;

  /* Named colors */
  --color-black-pearl: #02020f;
  --color-athens-gray: #f7f7fa;
  --color-mystic: #e6e6f0;
  --color-vulcan: #11111f;
  --color-charade: #242433;
  --color-waterloo: #77778c;
  --color-anakiwa: #93b6ff;
}
```

**Result:** In this configuration, we extend the default TailwindCSS theme to include custom colors for primary and secondary palettes.
The custom variants are used to apply the theme dark or light to elements.

&nbsp;

### Creating a reusable component with a custom theme
You can also pass a theme directly to any component as a prop. This will override the theme for that component, but not its children.
This is useful if you want to create a reusable component with a theme that differs from the global theme.

```tsx
import { tooltipTheme, TooltipTheme, extendComponentTheme } from 'reablocks';

const customTheme = extendComponentTheme<TooltipTheme>(tooltipTheme, {
  base: 'rounded bg-green-800 text-white font-bold p-3 text-base'
});

export const CustomTooltip = () => (
  <Tooltip theme={customTheme} content="Hi there">Hover me</Tooltip>
);
```

================
File: src/pages/docs/theme/theme-api.mdx
================
# Theme API
Below is the TypeScript API for the theme. You can
use this to define your theme and pass it to the provider.

## Default theme
Default theme for each component you could find [here](https://storybook.reablocks.dev/?path=/story/components-theme--components).

```ts
export interface ReablocksTheme {
  components: {
    avatar: AvatarTheme;
    avatarGroup: AvatarGroupTheme;
    arrow: ArrowTheme;
    badge: BadgeTheme;
    button: ButtonTheme;
    block: BlockTheme;
    chip: ChipTheme;
    contextMenu: ContextMenuTheme;
    checkbox: CheckboxTheme;
    dateFormat: DateFormatTheme;
    dialog: DialogTheme;
    divider: DividerTheme;
    dotsLoader: DotsLoaderTheme;
    drawer: DrawerTheme;
    ellipsis: EllipsisTheme;
    select: SelectTheme;
    list: ListTheme;
    menu: MenuTheme;
    sort: SortTheme;
    stack: StackTheme;
    card: CardTheme;
    kbd: KbdTheme;
    verticalSpacer: VerticalSpacerTheme;
    notification: NotificationTheme;
    input: InputTheme;
    calendar: CalendarTheme;
    calendarRange: CalendarRangeTheme;
    commandPalette: CommandPaletteTheme;
    collapse: CollapseTheme;
    textarea: TextareaTheme;
    typography: TypographyTheme;
    radio: RadioTheme;
    range: RangeTheme;
    redact: RedactTheme;
    toggle: ToggleTheme;
    tooltip: TooltipTheme;
    tree: TreeTheme;
    jsonTree: JsonTreeTheme;
    popover: PopoverTheme;
    pager: PagerTheme;
    tabs: TabsTheme;
    breadcrumbs: BreadcrumbsTheme;
    stepper: StepperTheme;
    callout: CalloutTheme;
  };
}

interface AvatarTheme {
  base: string;
  rounded: string;
}

interface AvatarGroupTheme {
  base: string;
  avatar: string;
  overflow: string;
}

interface ArrowTheme {
  base: string;
  up: string;
  down: string;
  right: string;
  left: string;
}

interface BadgeTheme {
  base: string;
  disableMargins: string;
  badge: string;
  position: string;
  colors: {
    default: string;
    primary: string;
    secondary: string;
    error: string;
  };
  positions: {
    'top-start': string;
    'top-end': string;
    'bottom-start': string;
    'bottom-end': string;
  };
}

interface ButtonTheme {
  base: string;
  disabled: string;
  fullWidth: string;
  group: string;
  groupText: string;
  adornment: {
    base: string;
    start: string;
    end: string;
    sizes: {
      small: string;
      medium: string;
      large: string;
    };
  };
  variants: {
    filled: string;
    outline: string;
    text: string;
  };
  colors: {
    default: {
      filled: string;
      outline: string;
      text: string;
    };
    primary: {
      filled: string;
      outline: string;
      text: string;
    };
    secondary: {
      filled: string;
      outline: string;
      text: string;
    };
    success: {
      filled: string;
      outline: string;
      text: string;
    };
    warning: {
      filled: string;
      outline: string;
      text: string;
    };
    error: {
      filled: string;
      outline: string;
      text: string;
    };
  };
  sizes: {
    small: string;
    medium: string;
    large: string;
  };
  iconSizes: {
    small: string;
    medium: string;
    large: string;
  }
}

interface BlockTheme {
  base: string;
  disableMargin: string;
  label: string;
  centerAlign: string;
  endAlign: string;
  horizontal: {
    base: string;
    label: string;
  };
  vertical: {
    base: string;
    label: string;
  };
}

interface ThemeColor {
  base?: string;
  variants?: {
    filled?: string;
    outline?: string;
  };
  selectable?: {
    base: string;
    variants?: {
      filled?: {
        base?: string;
        selected?: string;
      };
      outline?: {
        base?: string;
        selected?: string;
      };
    };
  };
}

interface ChipTheme {
  base: string;
  adornment: {
    base: string;
    start: string;
    end: string;
    sizes: {
      small: string;
      medium: string;
      large: string;
    };
  };
  variants: {
    filled: string;
    outline: string;
  };
  colors: {
    default: ThemeColor;
    primary?: ThemeColor;
    secondary?: ThemeColor;
    success?: ThemeColor;
    warning?: ThemeColor;
    error?: ThemeColor;
    info?: ThemeColor;
  };
  sizes: {
    small: string;
    medium: string;
    large: string;
  };
  focus: string;
  deleteButton: {
    base: string;
    sizes: {
      small: string;
      medium: string;
      large: string;
    };
  };
  disabled: string;
}

interface ContextMenuTheme {
  enabled: string;
}

interface CheckboxTheme {
  base: string;
  label: {
    base: string;
    clickable: string;
    sizes: {
      small: string;
      medium: string;
      large: string;
    };
  };
  border: string;
  check: string;
  checkbox: string;
  disabled: string;
  sizes: {
    small: string;
    medium: string;
    large: string;
  };
  boxVariants: {
    hover: {
      strokeWidth: number;
      stroke: string;
      fill: string;
    };
    pressed: {
      scale: number;
    };
    checked: {
      stroke: string;
      fill: string;
    };
    unchecked: {
      stroke: string;
      fill: string;
    };
  };
}

interface DateFormatTheme {
  base: string;
  interactive: string;
}

interface DialogTheme {
  base: string;
  inner: string;
  content: string;
  footer: string;
  header: {
    base: string;
    text: string;
    closeButton: string;
  };
}

interface DialogHeaderTheme {
  base: string;
  text: string;
  closeButton: string;
}

interface DividerTheme {
  base?: string;
  orientation?: {
    vertical?: string;
    horizontal?: string;
  };
  variant?: {
    primary?: string;
    secondary?: string;
  };
  disableMargins?: string;
}

interface DotsLoaderTheme {
  base: string;
  dot: string;
  sizes: {
    small: string;
    medium: string;
    large: string;
  };
}

interface DrawerTheme {
  base: string;
  header: {
    base: string;
    text: string;
  };
  content: string;
  disablePadding: string;
  closeButton: {
    base: string;
    headerless: string;
  };
  positions: {
    top: string;
    end: string;
    bottom: string;
    start: string;
  };
}

interface EllipsisTheme {
  dots: string;
}

interface SelectTheme {
  selectInput: SelectInputTheme;
  selectMenu: SelectMenuTheme;
}

interface SelectInputTheme {
  base: string;
  inputContainer: string;
  input: string;
  placeholder: string;
  prefix: string;
  suffix: {
    container: string;
    button: string;
    refresh: string;
    loader: string;
    close: string;
    expand: string;
  };
  disabled: string;
  unfilterable: string;
  error: string;
  single: {
    prefix: string;
    inputContainer: string;
    input: string;
  };
  multiple: {
    prefix: string;
    inputContainer: string;
  };
  open: string;
  chip: {
    base: string;
    hover: string;
    focused: string;
    disabled: string;
    removeButton: string;
  };
}

interface SelectMenuTheme {
  base: string;
  groupItem: string;
  groupTitle: string;
  option: {
    base: string;
    hover: string;
    selected: string;
    active: string;
    disabled: string;
  };
}

interface ListTheme {
  base: string;
  header: string;
  listItem: {
    base: string;
    disabled: string;
    active: string;
    clickable: string;
    disablePadding: string;
    disableGutters: string;
    dense: {
      base: string;
      content: string;
      startAdornment: string;
      endAdornment: string;
    };
    adornment: {
      base: string;
      start: string;
      end: string;
      svg: string;
    };
    content: string;
  };
}

interface MenuTheme {
  base: string;
  inner: string;
}

interface SortTheme {
  base: string;
  disabled: string;
  hasValue: string;
  icon: {
    base: string;
    ascending: string;
  };
}

interface StackTheme {
  base: string;
  dense: string;
  inline: string;
  direction: {
    row: string;
    column: string;
    rowReverse: string;
    columnReverse: string;
  };
  alignItems: {
    start: string;
    end: string;
    center: string;
    stretch: string;
  };
  justifyContent: {
    start: string;
    end: string;
    center: string;
    spaceBetween: string;
  };
}

interface CardTheme {
  base: string;
  disablePadding: string;
  header: string;
  headerText: string;
  content: string;
}

interface KbdTheme {
  base: string;
  chip: string;
}

interface VerticalSpacerTheme {
  base: string;
  size: {
    xs: string;
    sm: string;
    md: string;
    lg: string;
    xl: string;
    xxl: string;
  };
}

interface NotificationTheme {
  container: string;
  positions: string;
  notification: {
    base: string;
    variants: {
      success: {
        base: string;
        icon?: string;
      };
      error: {
        base: string;
        icon?: string;
      };
      warning: {
        base: string;
        icon?: string;
      };
      info: {
        base: string;
        icon?: string;
      };
    };
    header: string;
    content: string;
    body: string;
    closeContainer: string;
    action: string;
    closeButton: string;
  };
}

interface InputTheme {
  base: string;
  input: string;
  inline: string;
  disabled: string;
  focused: string;
  fullWidth: string;
  error: string;
  sizes: {
    small: string;
    medium: string;
    large: string;
  };
  adornment: {
    base: string;
    start: string;
    end: string;
  };
}

interface CalendarTheme {
  base: string;
  header: {
    base: string;
    prev: string;
    mid: string;
    next: string;
  };
  title: string;
  content: string;
  days: {
    header: string;
    dayOfWeek: string;
    week: string;
    day: string;
    outside: string;
    startRangeDate: string;
    cornerStartDateBottom: string;
    endRangeDate: string;
    cornerEndDateTop: string;
    range: string;
  };
  months: {
    root: string;
    month: string;
  };
  years: {
    root: string;
    year: string;
  };
}

interface CalendarRangeTheme extends Omit<CalendarTheme, 'months' | 'years'> {}

interface CommandPaletteTheme {
  base: string;
  inner: string;
  input: {
    base: string;
    input: string;
    icon: string;
  };
  item: {
    base: string;
    active: string;
    clickable: string;
  };
  section: {
    base: string;
    first: string;
  };
}

interface CollapseTheme {
  base: string;
}

interface TextareaTheme {
  base: string;
  input: string;
  fullWidth: string;
  error: string;
  disabled: string;
  sizes: {
    small: string;
    medium: string;
    large: string;
  };
}

interface TypographyTheme {
  base?: string;
  text?: {
    thin?: string;
    bold?: string;
    extraBold?: string;
    italic?: string;
  };
  variant?: {
    default?: string;
    mono?: string;
  };
  colors?: {
    primary: string;
    secondary: string;
    success: string;
    warning: string;
    error: string;
    info: string;
  };
  sub: string;
  smallHeading: string;
  secondaryHeading: string;
  primaryHeading: string;
  pageTitle: string;
  disableMargins?: string;
}

interface RadioTheme {
  base: string;
  radio: {
    base: string;
    disabled: string;
    checked: string;
  };
  indicator: {
    base: string;
    sizes: {
      small: string;
      medium: string;
      large: string;
    };
  };
  label: {
    base: string;
    clickable: string;
  };
  sizes: {
    small: string;
    medium: string;
    large: string;
  };
}

interface RangeTheme {
  base: string;
  drag: string;
  rangeHighlight: {
    base: string;
    disabled: string;
  };
  disabled: string;
  inputWrapper: {
    base: string;
    disabled: string;
  };
  input: string;
  tooltip: string;
}

interface RedactTheme {
  base: string;
  interactive: string;
}

interface ToggleTheme {
  base: string;
  disabled: string;
  checked: string;
  handle: {
    base: string;
    sizes: {
      small: string;
      medium: string;
      large: string;
    };
  };
  sizes: {
    small: string;
    medium: string;
    large: string;
  };
}

interface TooltipTheme {
  base: string;
  disablePointer: string;
}

interface TreeTheme {
  base: string;
  tree: string;
  arrow: string;
  node: {
    base: string;
    collapsed: string;
    disabled: string;
    leaf: string;
    label: string;
    button: {
      base: string;
      icon: string;
    };
  };
  nodeBlock: string;
  subtree: string;
}

interface PagerTheme {
  base: string;
  pages: {
    base: string;
    page: {
      base: string;
      active: string;
    };
  };
  ellipsis: string;
  pagerDisplayItems: string;
  control: string;
  firstPage: string;
  prevPage: string;
  lastPage: string;
  nextPage: string;
}

interface PopoverTheme {
  base: string;
  disablePadding: string;
}

interface TabsTheme {
  base: string;
  list: {
    base: string;
    indicator: {
      base: string;
      size: {
        small: string;
        medium: string;
        large: string;
      };
    };
    divider: string;
    variant: {
      primary: {
        divider: string;
      };
      secondary: {
        divider: string;
      };
    };
    tab: {
      base: string;
      button: string;
      selected: string;
      disabled: string;
      size: {
        small: string;
        medium: string;
        large: string;
      };
    };
  };
  panel: string;
}

interface StepperTheme {
  base: string;
  step: {
    base: string;
    marker: {
      container: string;
      base: string;
      active: string;
      label: {
        base: string;
        active: string;
      };
    };
    active: string;
    content: string;
  };
}

export interface CalloutTheme {
  base: {
    common: string;
    variant: {
      default: string;
      success: string;
      error: string;
      warning: string;
      info: string;
      [key: string]: string;
    };
  };
  icon: {
    common: string;
    variant: {
      default: string;
      success: string;
      error: string;
      warning: string;
      info: string;
      [key: string]: string;
    };
  };
  text: string;
}
```

================
File: src/pages/docs/theme/theme-block.mdx
================
import { ColorBlocksExample, TypographyBlocksExample, SpacingBlocksExample, BorderBlocksExample } from '@/components/ui/blocks';

# Theme Blocks
Theme blocks are a collection of components designed to display the various elements of your theme within Storybook.
These components offer a visual representation of your design system, including typography, colors, spacing, borders, shadows, palette variations, and more.
By incorporating these blocks into your Storybook, you can easily document and showcase your theme's design tokens.

### Available Theme Block Components
- **Typography Block:** Demonstrates the font families, sizes, and weights available in your theme.
- **Color Block:** Displays the color palette defined in your theme, including primary, secondary, and any other custom colors.
- **Spacing Block:** Visualizes the spacing scale used in your theme, helpful for understanding and using consistent spacing throughout your UI.
- **Border Block:** Shows the available border radius options, aiding in the application of consistent border styles.
- **Shadow Block:** Exhibits the shadow options defined in your theme, making it easy to apply consistent shadow effects.
- **Components Block:** A comprehensive showcase of the styled components within your theme, including buttons, inputs, and more.
- **Icons Block:** Displays the icons used in your theme. **NOTE** that icons are not included and must be supplied.

## Implementing Theme Blocks in a Storybook Story

Below is an example that demonstrates how to use the theme block components in a Storybook story.

```tsx
import React from 'react';
import {
  TypographyBlocks,
  ColorBlocks,
  SpacingBlocks,
  BorderBlocks,
  ShadowBlocks,
  ThemeProvider,
  theme,
  useTheme,
  extractTheme
} from 'reablocks';

const { theme: TWConfig } = resolveConfig(tailwindConfig);

export default {
  title: 'Components/Theme',
  decorators: [
    Story => {
      const { tokens } = useTheme();

      const {
        colors,
        borderRadius,
        boxShadow,
        spacing,
        fontFamily,
        fontSize,
        fontWeight
      } = extractTheme(tokens);

      return (
        <div style={{ width: '95vw' }}>
          <Story
            colors={colors}
            borderRadius={borderRadius}
            boxShadow={boxShadow}
            spacing={spacing}
            fontFamily={fontFamily}
            fontSize={fontSize}
            fontWeight={fontWeight}
          />
        </div>
      );
    }
  ]
};


export const Colors = (_: unknown, { colors }) => {
  return <ColorBlocks colors={colors} />;
};

export const Typography = (
  __: unknown,
  { fontFamily, fontSize, fontWeight }
) => (
  <TypographyBlocks
    families={fontFamily}
    sizes={fontSize}
    weights={fontWeight}
  />
);

export const Spacings = (__: unknown, { spacing }) => (
  <SpacingBlocks spacings={spacing} />
);

export const Borders = (_: unknown, { borderRadius }) => (
  <BorderBlocks borders={borderRadius} />
);

export const Shadows = (_: unknown, { boxShadow }) => (
  <ShadowBlocks shadows={boxShadow} />
);

export const Components = () => {
  const { theme } = useTheme();
  return <ComponentBlocks components={theme.components} />;
};

export const Icons = () => (
  <>
    <h2>Icon Block Helper ( icons not included )</h2>
    <IconBlocks
      icons={[
        {
          name: 'favorite',
          src: favoriteIcon
        },
        {
          name: 'another favorite',
          src: favoriteIcon
        }
      ]}
    />
  </>
);

````

**NOTE:** This example utilizes the `ThemeProvider` in the story decorator, allowing each story
to inherit the dark theme context. Alternatively, you could use `ThemeProvider` in your
`.storybook/preview.js` file to apply the theme globally to all stories.

You can see how it looks in the Storybook
[here](https://storybook.reablocks.dev/?path=/story/components-theme--colors).

================
File: src/pages/docs/theme/theme-example.mdx
================
# Theme Customization: Button Example

This section demonstrates the customization options available for buttons within our `darkTheme`.
Our aim is to provide a flexible design that can be easily integrated across different parts of your application,
ensuring consistency while offering room for customization.

### Theme Properties Explaination
- `base`: Sets the foundational style for all buttons, including text color, padding, and border radius.
- `disabled`: Defines styles for disabled buttons, including cursor changes and color adjustments.
- `fullWidth`: Adjusts the button to span the full width of its container.
- `group`: Customizes the appearance of buttons when they are grouped together.
- `adornment`: Configures styles for icons used within buttons, with size adjustments for small, medium, and large buttons.
- `sizes`: Offers predefined size options for buttons, affecting padding, font size, and line height.
- `variants`: Allows for different button styles, such as filled, outlined, or text-only.
- `colors`: Provides color schemes for buttons based on their intended use (e.g., primary, secondary, success, or any custom color).

```ts
import { PartialReablocksTheme, ButtonTheme } from 'reablocks';

const buttonTheme: ButtonTheme = {
  base: 'bg-lime-600 text-gray-300',
  sizes: {
    small: 'p-2',
    medium: 'p-3',
    large: 'p-4'
  },
  colors: {
    default: {
      filled: 'bg-lime-600 hover:bg-lime-700',
      outline: 'border-lime-600',
      text: 'text-gray-300'
    }
  }
};

const customTheme: PartialReablocksTheme = {
  components: {
    button: buttonTheme,
    // other components themes
  }
};
```

### Best Practices
- Use the `filled` variant for primary actions to draw attention.
- Reserve the `outline` and `text` variants for secondary actions or less prominent interfaces.
- Consider the context and background when choosing button colors to ensure sufficient contrast and accessibility.

================
File: src/pages/docs/theme/theme-icons.mdx
================
# Theme Icons
Out of the box, reablocks **doesn't** include any icons, however, you
can you use any icon library you want. This is because reablocks
wants to stay true to our core values of being unopinionated and
lightweight.

Reablocks offers helpers to make it easier to document icons
in your Storybook. Below is an example of how to use the helper components.

### Creating an Icon Loader
Begin by creating a file to load and organize your SVG icons.
If you're using [Vite](https://vitejs.dev/), you can take advantage of its glob import feature to dynamically load your icons.
Create a file named `icons.ts` (or `icons.js` if you're using JavaScript) in your project.

```tsx
import React from 'react';

const iconPaths = import.meta.glob('./*.svg');

export const icons = Object.keys(iconPaths).map(key => ({
  name: key.replace('.svg', '').replace('./', ''),
  component: React.lazy(async () => {
    const lazy: any = await iconPaths[key]();
    return { default: lazy.ReactComponent };
  })
}));
```
**Result:** This script dynamically loads all SVG icons from the specified directory, prepares them as React components, and exports them in a format compatible with reablocks' `IconBlocks` component.

### Documenting Icons in Storybook
With your icons prepared, the next step is to document them in Storybook.
Create a Storybook MDX file named `Icons.stories.mdx` to showcase your icons library.

```tsx
import { Meta } from '@storybook/addon-docs';
import { IconBlocks } from 'reablocks';
import { icons } from './icons';

<Meta title="General/Icons" />

<style>
body {
  --icon-block-color: #fff;
  --icon-block-background: #000;
}
</style>

## Icons
<IconBlocks icons={icons} />
```
**Result:** This MDX file does the following:
- Imports the icons you prepared earlier.
- Uses the IconBlocks component from reablocks to display each icon alongside its name.

================
File: src/pages/docs/utils/component-theme.mdx
================
# useComponentTheme hook

The `useComponentTheme` is a hook that allows developers to get theme of a component.
It also allows developers to override the default theme of a component by passing a custom theme.

## Examples

In the below example, we are using `useComponentTheme` hook to get the theme of a button component.
The `Button` actually passes `customTheme` prop to the `useComponentTheme`
hook to override the default theme. If no `customTheme` is passed, the default theme is used.

```jsx
import { useComponentTheme } from 'reablocks';

function Button({ customTheme }) {
  const theme = useComponentTheme('button', customTheme);

  return (
    <button className={theme.button}>
      Hello World
    </button>
  );
}
```

================
File: src/pages/docs/utils/cursor.mdx
================
# Cursor

A small hook that sets the css body cursor according to
a state. This is useful for dragging when
cursors go outside the thing they are dragging.

## Examples

```jsx
const [hovered, setHovered] = useState()

useCursor(hovered, 'grabbing') // -> sets body to grabbing
```

================
File: src/pages/docs/utils/exit-listener.mdx
================
import { Canvas, Meta } from '@storybook/blocks';
import * as ExitListenerStories from '../../../stories/components/ExitListener.story.tsx';
import { ToggleCanvas } from '@/components/ui/toggle-canvas';

<Meta of={ExitListenerStories} />

# Exit Listener

The exit listener is a hook that allows developers to subscribe to
click events and escape keyboard events on a root element.

A typical example of this would be a menu, when a user opens the menu we want
to listen for events if a user clicks anywhere but our menu to notify
the parent to close it.

## Examples
<ToggleCanvas of={ExitListenerStories.Simple} />

================
File: src/pages/docs/utils/id.mdx
================
# Id
Autogenerate IDs to facilitate WAI-ARIA.

A string can be supplied as an argument to be useId in lieu of the auto-generated ID.
This is handy for accepting user-provided prop IDs that need to be deterministic.

## Examples

```jsx
// Auto generate one...
const id = useId();

// Provide your own...
const myId = useId('foo-1');
```

================
File: src/pages/docs/utils/overlay.mdx
================
import { Canvas, Meta } from '@storybook/blocks';
import { PropsTable } from '@/components/ui/props-table';
import { ToggleCanvas } from '@/components/ui/toggle-canvas';
import * as GlobalOverlayStories from '../../../stories/components/GlobalOverlay.story.tsx';
import * as ConnectedOverlayStories from '../../../stories/components/ConnectedOverlay.story.tsx';
import * as OverlayTriggerStories from '../../../stories/components/OverlayTrigger.story.tsx';
import * as OverlayPortalStories from '../../../stories/components/OverlayPortal.story.tsx';

<Meta of={GlobalOverlayStories} />
<Meta of={ConnectedOverlayStories} />
<Meta of={OverlayTriggerStories} />
<Meta of={OverlayPortalStories} />

# Overlay

Overlay provides component developers a way to position elements globally
or relative to a anchor element. The overlay wraps the backdrop, position, exit
listener and portal to provide a simple API for handling position.

There are five overlay components in the Overlay:

- `ConnectedOverlay` - A overlay that is relative to a anchoring element.
- `GlobalOverlay` - A overlay that is placed on top of other elements globally.
- `OverlayPortal` - A wrapper around the portal component to manage z-indexs.
- `OverlayTrigger` - The internal trigger component that the `ConnectedOverlay` uses.

## Examples

### Global Overlay
A overlay component typically used by components like Dialogs or Drawers.
You can use the Global Ovleray using element APIs.


Use the css variable `--color-layer-transparent` to set the backdrop color.

```css
// index.css

body {
  --color-layer-transparent: rgba(0, 0, 0, 0.5);
}
```

<ToggleCanvas of={GlobalOverlayStories.ClickToOpen} />

#### Dialog Example
Below is an example of a simple dialog component using the global overlay.

<ToggleCanvas of={GlobalOverlayStories.DialogExample} />

### Connected Overlay
A overlay component typically used by components like menus.

<ToggleCanvas of={ConnectedOverlayStories.Simple} />

#### Tooltip Example
Below is an example of simple tooltip component using the connected overlay.

<ToggleCanvas of={ConnectedOverlayStories.TooltipExample} />

#### Menu Example
Below is an example of simple menu component using the connected overlay.

<ToggleCanvas of={ConnectedOverlayStories.MenuExample} />

## API
### [GlobalOverlay](https://github.com/reaviz/reablocks/blob/master/src/utils/Overlay/GlobalOverlay/GlobalOverlay.tsx)
<PropsTable name='GlobalOverlay' />

### [ConnectedOverlay](https://github.com/reaviz/reablocks/blob/master/src/utils/Overlay/ConnectedOverlay/ConnectedOverlay.tsx)
<PropsTable name='ConnectedOverlay' />

### [OverlayTrigger](https://github.com/reaviz/reablocks/blob/master/src/utils/Overlay/OverlayTrigger.tsx)
<PropsTable name='OverlayTrigger' />

### [OverlayPortal](https://github.com/reaviz/reablocks/blob/master/src/utils/Overlay/OverlayPortal/OverlayPortal.tsx)
<PropsTable name='OverlayPortal' />

================
File: src/pages/docs/utils/portal.mdx
================
import { Canvas, Meta } from '@storybook/blocks';
import { PropsTable } from '@/components/ui/props-table';
import { ToggleCanvas } from '@/components/ui/toggle-canvas';
import * as PortalStories from '../../../stories/components/Portal.story.tsx';
import { Portal } from 'reablocks';

<Meta of={PortalStories} />

# Portal

The portal is a component that wraps React's `createPortal` method
to provide a better DX for creating portals. It will automatically
inject elements to the body rather than having to manually do that
via the core method in React.

## Examples
This component can be used via element api.

<ToggleCanvas of={PortalStories.Simple} />

## API
### [Portal](https://github.com/reaviz/reablocks/blob/master/src/utils/Portal/Portal.ts)
<PropsTable name="Portal" />

================
File: src/pages/docs/utils/position.mdx
================
import { Canvas, Meta } from '@storybook/blocks';
import { PropsTable } from '@/components/ui/props-table';
import { ToggleCanvas } from '@/components/ui/toggle-canvas';
import * as PositionStories from '../../../stories/components/Position.story.tsx';

<Meta of={PositionStories} />

# Position

Position is a component that is used to position elements absolutely
with respect to their target element. Under the hood this component
uses [Floating UI](https://floating-ui.com/).

## Examples
<ToggleCanvas of={PositionStories.Simple} />

================
File: src/pages/docs/utils/theme.mdx
================
# useTheme hook

The `useTheme` is a hook that allows developers to get the global theme.
This will return all the theme options that are available in the global theme.

## Examples
Below is an example of using the `useTheme` hook to get two different component
themes to theme a custom button.

```jsx
import { useTheme } from 'reablocks';

function Button() {
  const theme = useTheme();

  return (
    <button className={theme.button.base}>
      Hello World
      <input className={theme.input.base} />
    </button>
  );
}
```

================
File: src/pages/docs/utils/user-select.mdx
================
# User Select

A small hook that sets the css body user select according to
a state. This is useful for dragging when
cursors go outside the thing they are dragging.

## Examples

```jsx
const [hovered, setHovered] = useState()

useUserSelect(hovered) // -> sets body to user-select: none
```

================
File: src/pages/docs/changelog.mdx
================
import { useData } from 'nextra/hooks'
import Mdx from '../../components/ui/mdx';

export const getStaticProps = ({ params }) => {
  return fetch(`https://raw.githubusercontent.com/reaviz/reablocks/master/CHANGELOG.md`)
    .then(res => res.text())
    .then(text => ({
      props: {
        ssg: {
          text
        }
      },
    }))
}

export const Result = () => {
  const { text } = useData();
  return (
    <Mdx>
      {text}
    </Mdx>
  );
}

<Result />

================
File: src/pages/docs/index.mdx
================
import img from '../../icons/preview.png';

<div className="my-0 mx-auto text-white text-center flex flex-col">
  <img
    className="mx-auto mb-8 mt-8"
    src={img.src}
  />
  <br />
  <div className="flex justify-center">
    <a href="https://github.com/reaviz/reablocks/actions/workflows/build.yml" target="_blank">
      <img src="https://github.com/reaviz/reablocks/actions/workflows/build.yml/badge.svg" />
    </a>
    <span>&nbsp;&nbsp;</span>
    <a href="https://npm.im/reablocks" target="_blank">
      <img src="https://img.shields.io/npm/v/reablocks.svg" />
    </a>
    <span>&nbsp;&nbsp;</span>
    <a href="https://npm.im/reablocks" target="_blank">
      <img src="https://badgen.net/npm/dw/reablocks" />
    </a>
    <span>&nbsp;&nbsp;</span>
    <a href="https://github.com/reaviz/reablocks/blob/master/LICENSE" target="_blank">
      <img src="https://badgen.now.sh/badge/license/apache2" />
    </a>
    <span>&nbsp;&nbsp;</span>
    <a href="https://github.com/reaviz/reablocks" target="_blank">
      <img alt="GitHub stars" src="https://img.shields.io/github/stars/reaviz/reablocks?style=social" />
    </a>
    <span>&nbsp;&nbsp;</span>
    <a href="https://discord.gg/tt8wGExq35" target="_blank">
      <img src="https://img.shields.io/discord/773948315037073409?label=discord" />
    </a>
  </div>

---
</div>

### What is reablocks?
reablocks is a set of beautifully designed, highly customizable, open-source React components
based on [Tailwind](https://tailwindcss.com/) and [Framer Motion](https://www.framer.com/motion/). It combines
the flexibility and ease of Tailwind CSS with the power of Framer Motion to create
a seamless and intuitive experience for building modern web applications.

### Why reablocks?
There are many React component libraries out there, but reablocks is unique in a few ways:

- **Highly Customizable**: reablocks is built on top of Tailwind CSS, which allows for a high level of customization and flexibility. You can easily change the look and feel of your components by tweaking the Tailwind classes. No longer are you locked into a specific design system or its opinions.
- **Seamless Animations**: reablocks uses Framer Motion for animations and transitions, which makes it easy to add motion to your components. You can create smooth animations with just a few lines of code.
- **Easy to Use**: reablocks provides a simple and intuitive API that makes it easy to build modern web applications. You can quickly create beautiful UIs without having to write a lot of custom CSS or JavaScript.
- **Batteries-Included**: reablocks comes with a set of pre-designed components that you can use out of the box. This includes logins, reset password, manage team and more.
- **Battle-Tested**: reablocks is used in production on dozens of enterprise products and has been battle-tested in real-world applications.
- **Storybook-first**: reablocks is built with Storybook in mind. Every component is documented with examples and usage guidelines in Storybook. You can even easily import these stories into your own Storybook setup.
- **Enterprise focused**: reablocks is built with enterprise applications in mind. It includes features components that lend themselves more towards business applications than consumer applications.
- **Open Source**: reablocks is open-source and free to use and we plan to keep it that way. You can use it in your personal or commercial projects.
- **Real Code, Not Wrappers**: reablocks is built with real code, not wrappers around existing libraries. Everything from the select box to the radial charts are all part of the [reaviz](https://github.com/reaviz) portfolio.

To learn more about why reablocks, check out the [Philosophy](/docs/getting-started/philosophy) page.

### How do I get started?
To get started with reablocks, check out the [Getting Started](/docs/getting-started/setup) page.
It will walk you through how to install reablocks and get up and running with your first component.

================
File: src/pages/support.mdx
================
# Support

We encourage users to make PRs and [log tickets](https://github.com/reaviz/reablocks/issues) for issues. We will try to respond to them as quickly as possible
but if you are in need of extra support, our team at [Good Code](https://goodcode.us?utm=reablocks) is here to help. Reach out
to us today to discuss our packages and support plans.




================================================================
End of Codebase
================================================================
